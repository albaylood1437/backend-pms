
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';


/**
 * Model department
 */

export type department = {
  departmentId: number
  departmentName: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model garage
 */

export type garage = {
  garageId: number
  garageName: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model itemPart
 */

export type itemPart = {
  itemPart: string
  partName: string
  partQuantity: number
  partPrice: number
  createdAt: Date | null
  updatedAt: Date | null
  id: number | null
  supplierId: number | null
}

/**
 * Model part
 */

export type part = {
  partId: number
  partName: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model serviceExpense
 */

export type serviceExpense = {
  id: number
  invoiceNumber: string
  serviceDescription: string | null
  serviceDate: Date | null
  serviceCost: number | null
  totalCost: number | null
  purchaseID: number | null
  createdAt: Date | null
  updatedAt: Date | null
  vehicleId: number | null
  garageId: number | null
}

/**
 * Model supplier
 */

export type supplier = {
  supplierId: number
  supplierName: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model users
 */

export type users = {
  userId: number
  username: string | null
  email: string
  isAdmin: string
  password: string
}

/**
 * Model vehicle
 */

export type vehicle = {
  vehicleId: number
  plateNumber: string
  model: string
  modelYear: number
  chasisNubmer: number
  purchaseDate: Date
  purchaseMileAge: number
  disposalDate: Date | null
  vehicleStatus: string | null
  departmentId: number | null
  location: string | null
  reason: string | null
}

/**
 * Model drivers
 */

export type drivers = {
  driverId: number
  driverName: string
  phone: string
  licensNo: number
  description: string | null
  driverStatus: string | null
}

/**
 * Model DeletedItemPart
 */

export type DeletedItemPart = {
  itemPart: string
  partName: string
  partQuantity: number
  partPrice: number
  createdAt: Date | null
  updatedAt: Date | null
  id: number
  supplierId: number | null
  garageId: number | null
}

/**
 * Model driving
 */

export type driving = {
  drivingId: number
  drivingDate: Date
  drivingDescription: string | null
  drivingStatus: string | null
  vehicleId: number | null
  driverId: number | null
  reason: string | null
}

/**
 * Model DeletedServiceExpense
 */

export type DeletedServiceExpense = {
  id: number
  invoiceNumber: string
  serviceDescription: string | null
  serviceDate: Date | null
  serviceCost: number | null
  totalCost: number | null
  purchaseID: number | null
  createdAt: Date | null
  updatedAt: Date | null
  vehicleId: number | null
  garageId: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Departments
 * const departments = await prisma.department.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Departments
   * const departments = await prisma.department.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.department`: Exposes CRUD operations for the **department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.departmentDelegate<GlobalReject>;

  /**
   * `prisma.garage`: Exposes CRUD operations for the **garage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Garages
    * const garages = await prisma.garage.findMany()
    * ```
    */
  get garage(): Prisma.garageDelegate<GlobalReject>;

  /**
   * `prisma.itemPart`: Exposes CRUD operations for the **itemPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemParts
    * const itemParts = await prisma.itemPart.findMany()
    * ```
    */
  get itemPart(): Prisma.itemPartDelegate<GlobalReject>;

  /**
   * `prisma.part`: Exposes CRUD operations for the **part** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.part.findMany()
    * ```
    */
  get part(): Prisma.partDelegate<GlobalReject>;

  /**
   * `prisma.serviceExpense`: Exposes CRUD operations for the **serviceExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceExpenses
    * const serviceExpenses = await prisma.serviceExpense.findMany()
    * ```
    */
  get serviceExpense(): Prisma.serviceExpenseDelegate<GlobalReject>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.vehicleDelegate<GlobalReject>;

  /**
   * `prisma.drivers`: Exposes CRUD operations for the **drivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.drivers.findMany()
    * ```
    */
  get drivers(): Prisma.driversDelegate<GlobalReject>;

  /**
   * `prisma.deletedItemPart`: Exposes CRUD operations for the **DeletedItemPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedItemParts
    * const deletedItemParts = await prisma.deletedItemPart.findMany()
    * ```
    */
  get deletedItemPart(): Prisma.DeletedItemPartDelegate<GlobalReject>;

  /**
   * `prisma.driving`: Exposes CRUD operations for the **driving** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivings
    * const drivings = await prisma.driving.findMany()
    * ```
    */
  get driving(): Prisma.drivingDelegate<GlobalReject>;

  /**
   * `prisma.deletedServiceExpense`: Exposes CRUD operations for the **DeletedServiceExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedServiceExpenses
    * const deletedServiceExpenses = await prisma.deletedServiceExpense.findMany()
    * ```
    */
  get deletedServiceExpense(): Prisma.DeletedServiceExpenseDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.16.1
   * Query Engine version: cf0680a1bfe8d5e743dc659cc7f08009f9587d58
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  /**
   * Allows creating `select` or `include` outside of the main statement
   * From https://github.com/prisma/prisma/issues/3372#issuecomment-762296484
   */

  type Cast<A1, A2> = A1 extends A2 ? A1 : A2;

  /**
   * `Exact` forces a type to comply by another type. It will need to be a subset
   * and must have exactly the same properties, no more, no less.
   */
  type Exact<A, W> = A & Cast<{
    [K in keyof A]: K extends keyof W ? A[K] : never
  }, W>;

  type Narrow<A, W = unknown> =
      A & {[K in keyof A]: NarrowAt<A, W, K>};

  type NarrowAt<A, W, K extends keyof A, AK = A[K], WK = Att<W, K>> =
      WK extends Widen<infer T> ? T :
      AK extends Narrowable ? AK & WK :
      Narrow<AK, WK>;

  type Att<O, K> = K extends keyof O ? O[K] : unknown;

  type Widen<A> = {[type]: A};

  type Narrowable =
  | string
  | number
  | bigint
  | boolean
  | [];

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<Narrow<S, V>, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    department: 'department',
    garage: 'garage',
    itemPart: 'itemPart',
    part: 'part',
    serviceExpense: 'serviceExpense',
    supplier: 'supplier',
    users: 'users',
    vehicle: 'vehicle',
    drivers: 'drivers',
    DeletedItemPart: 'DeletedItemPart',
    driving: 'driving',
    DeletedServiceExpense: 'DeletedServiceExpense'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model department
   */


  export type AggregateDepartment = {
    count: DepartmentCountAggregateOutputType | null
    avg: DepartmentAvgAggregateOutputType | null
    sum: DepartmentSumAggregateOutputType | null
    min: DepartmentMinAggregateOutputType | null
    max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    departmentId: number
  }

  export type DepartmentSumAggregateOutputType = {
    departmentId: number
  }

  export type DepartmentMinAggregateOutputType = {
    departmentId: number
    departmentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    departmentId: number
    departmentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    departmentId: number
    departmentName: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    departmentId?: true
  }

  export type DepartmentSumAggregateInputType = {
    departmentId?: true
  }

  export type DepartmentMinAggregateInputType = {
    departmentId?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    departmentId?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    departmentId?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs = {
    /**
     * Filter which department to aggregate.
    **/
    where?: departmentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of departments to fetch.
    **/
    orderBy?: Enumerable<departmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
    [P in keyof T & keyof AggregateDepartment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }



  export type departmentSelect = {
    departmentId?: boolean
    departmentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleFindManyArgs
  }

  export type departmentInclude = {
    vehicle?: boolean | vehicleFindManyArgs
  }

  export type departmentGetPayload<
    S extends boolean | null | undefined | departmentArgs,
    U = keyof S
      > = S extends true
        ? department
    : S extends undefined
    ? never
    : S extends departmentArgs | departmentFindManyArgs
    ?'include' extends U
    ? department  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'vehicle'
        ? Array < vehicleGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof department ?department [P]
  : 
          P extends 'vehicle'
        ? Array < vehicleGetPayload<S['select'][P]>>  : never
  } 
    : department
  : department


  type departmentCountArgs = Merge<
    Omit<departmentFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentCountAggregateInputType | true
    }
  >

  export interface departmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Department that matches the filter.
     * @param {departmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends departmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, departmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'department'> extends True ? CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>> : CheckSelect<T, Prisma__departmentClient<department | null >, Prisma__departmentClient<departmentGetPayload<T> | null >>

    /**
     * Find the first Department that matches the filter.
     * @param {departmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends departmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, departmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'department'> extends True ? CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>> : CheckSelect<T, Prisma__departmentClient<department | null >, Prisma__departmentClient<departmentGetPayload<T> | null >>

    /**
     * Find zero or more Departments that matches the filter.
     * @param {departmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `departmentId`
     * const departmentWithDepartmentIdOnly = await prisma.department.findMany({ select: { departmentId: true } })
     * 
    **/
    findMany<T extends departmentFindManyArgs>(
      args?: SelectSubset<T, departmentFindManyArgs>
    ): CheckSelect<T, Promise<Array<department>>, Promise<Array<departmentGetPayload<T>>>>

    /**
     * Create a Department.
     * @param {departmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
    **/
    create<T extends departmentCreateArgs>(
      args: SelectSubset<T, departmentCreateArgs>
    ): CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>>

    /**
     * Delete a Department.
     * @param {departmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
    **/
    delete<T extends departmentDeleteArgs>(
      args: SelectSubset<T, departmentDeleteArgs>
    ): CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>>

    /**
     * Update one Department.
     * @param {departmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends departmentUpdateArgs>(
      args: SelectSubset<T, departmentUpdateArgs>
    ): CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>>

    /**
     * Delete zero or more Departments.
     * @param {departmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends departmentDeleteManyArgs>(
      args?: SelectSubset<T, departmentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Departments.
     * @param {departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends departmentUpdateManyArgs>(
      args: SelectSubset<T, departmentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {departmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
    **/
    upsert<T extends departmentUpsertArgs>(
      args: SelectSubset<T, departmentUpsertArgs>
    ): CheckSelect<T, Prisma__departmentClient<department>, Prisma__departmentClient<departmentGetPayload<T>>>

    /**
     * Count the number of Departments.
     * @param {departmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentCountArgs>(
      args?: Subset<T, departmentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Promise<GetDepartmentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__departmentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vehicle<T extends vehicleFindManyArgs = {}>(args?: Subset<T, vehicleFindManyArgs>): CheckSelect<T, Promise<Array<vehicle>>, Promise<Array<vehicleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * department findUnique
   */
  export type departmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * Throw an Error if a department can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which department to fetch.
    **/
    where: departmentWhereUniqueInput
  }


  /**
   * department findFirst
   */
  export type departmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * Throw an Error if a department can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which department to fetch.
    **/
    where?: departmentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of departments to fetch.
    **/
    orderBy?: Enumerable<departmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
    **/
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of departments.
    **/
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * department findMany
   */
  export type departmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * Filter, which departments to fetch.
    **/
    where?: departmentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of departments to fetch.
    **/
    orderBy?: Enumerable<departmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
    **/
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
    **/
    skip?: number
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * department create
   */
  export type departmentCreateArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * The data needed to create a department.
    **/
    data: XOR<departmentUncheckedCreateInput, departmentCreateInput>
  }


  /**
   * department update
   */
  export type departmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * The data needed to update a department.
    **/
    data: XOR<departmentUncheckedUpdateInput, departmentUpdateInput>
    /**
     * Choose, which department to update.
    **/
    where: departmentWhereUniqueInput
  }


  /**
   * department updateMany
   */
  export type departmentUpdateManyArgs = {
    data: XOR<departmentUncheckedUpdateManyInput, departmentUpdateManyMutationInput>
    where?: departmentWhereInput
  }


  /**
   * department upsert
   */
  export type departmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * The filter to search for the department to update in case it exists.
    **/
    where: departmentWhereUniqueInput
    /**
     * In case the department found by the `where` argument doesn't exist, create a new department with this data.
    **/
    create: XOR<departmentUncheckedCreateInput, departmentCreateInput>
    /**
     * In case the department was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<departmentUncheckedUpdateInput, departmentUpdateInput>
  }


  /**
   * department delete
   */
  export type departmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
    /**
     * Filter which department to delete.
    **/
    where: departmentWhereUniqueInput
  }


  /**
   * department deleteMany
   */
  export type departmentDeleteManyArgs = {
    where?: departmentWhereInput
  }


  /**
   * department without action
   */
  export type departmentArgs = {
    /**
     * Select specific fields to fetch from the department
    **/
    select?: departmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: departmentInclude | null
  }



  /**
   * Model garage
   */


  export type AggregateGarage = {
    count: GarageCountAggregateOutputType | null
    avg: GarageAvgAggregateOutputType | null
    sum: GarageSumAggregateOutputType | null
    min: GarageMinAggregateOutputType | null
    max: GarageMaxAggregateOutputType | null
  }

  export type GarageAvgAggregateOutputType = {
    garageId: number
  }

  export type GarageSumAggregateOutputType = {
    garageId: number
  }

  export type GarageMinAggregateOutputType = {
    garageId: number
    garageName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GarageMaxAggregateOutputType = {
    garageId: number
    garageName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GarageCountAggregateOutputType = {
    garageId: number
    garageName: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type GarageAvgAggregateInputType = {
    garageId?: true
  }

  export type GarageSumAggregateInputType = {
    garageId?: true
  }

  export type GarageMinAggregateInputType = {
    garageId?: true
    garageName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GarageMaxAggregateInputType = {
    garageId?: true
    garageName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GarageCountAggregateInputType = {
    garageId?: true
    garageName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GarageAggregateArgs = {
    /**
     * Filter which garage to aggregate.
    **/
    where?: garageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of garages to fetch.
    **/
    orderBy?: Enumerable<garageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: garageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` garages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` garages.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned garages
    **/
    count?: true | GarageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GarageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GarageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GarageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GarageMaxAggregateInputType
  }

  export type GetGarageAggregateType<T extends GarageAggregateArgs> = {
    [P in keyof T & keyof AggregateGarage]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGarage[P]>
      : GetScalarType<T[P], AggregateGarage[P]>
  }



  export type garageSelect = {
    garageId?: boolean
    garageName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DeletedItemPart?: boolean | DeletedItemPartFindManyArgs
    DeletedServiceExpense?: boolean | DeletedServiceExpenseFindManyArgs
    serviceExpense?: boolean | serviceExpenseFindManyArgs
  }

  export type garageInclude = {
    DeletedItemPart?: boolean | DeletedItemPartFindManyArgs
    DeletedServiceExpense?: boolean | DeletedServiceExpenseFindManyArgs
    serviceExpense?: boolean | serviceExpenseFindManyArgs
  }

  export type garageGetPayload<
    S extends boolean | null | undefined | garageArgs,
    U = keyof S
      > = S extends true
        ? garage
    : S extends undefined
    ? never
    : S extends garageArgs | garageFindManyArgs
    ?'include' extends U
    ? garage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'DeletedItemPart'
        ? Array < DeletedItemPartGetPayload<S['include'][P]>>  :
        P extends 'DeletedServiceExpense'
        ? Array < DeletedServiceExpenseGetPayload<S['include'][P]>>  :
        P extends 'serviceExpense'
        ? Array < serviceExpenseGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof garage ?garage [P]
  : 
          P extends 'DeletedItemPart'
        ? Array < DeletedItemPartGetPayload<S['select'][P]>>  :
        P extends 'DeletedServiceExpense'
        ? Array < DeletedServiceExpenseGetPayload<S['select'][P]>>  :
        P extends 'serviceExpense'
        ? Array < serviceExpenseGetPayload<S['select'][P]>>  : never
  } 
    : garage
  : garage


  type garageCountArgs = Merge<
    Omit<garageFindManyArgs, 'select' | 'include'> & {
      select?: GarageCountAggregateInputType | true
    }
  >

  export interface garageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Garage that matches the filter.
     * @param {garageFindUniqueArgs} args - Arguments to find a Garage
     * @example
     * // Get one Garage
     * const garage = await prisma.garage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends garageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, garageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'garage'> extends True ? CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>> : CheckSelect<T, Prisma__garageClient<garage | null >, Prisma__garageClient<garageGetPayload<T> | null >>

    /**
     * Find the first Garage that matches the filter.
     * @param {garageFindFirstArgs} args - Arguments to find a Garage
     * @example
     * // Get one Garage
     * const garage = await prisma.garage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends garageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, garageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'garage'> extends True ? CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>> : CheckSelect<T, Prisma__garageClient<garage | null >, Prisma__garageClient<garageGetPayload<T> | null >>

    /**
     * Find zero or more Garages that matches the filter.
     * @param {garageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Garages
     * const garages = await prisma.garage.findMany()
     * 
     * // Get first 10 Garages
     * const garages = await prisma.garage.findMany({ take: 10 })
     * 
     * // Only select the `garageId`
     * const garageWithGarageIdOnly = await prisma.garage.findMany({ select: { garageId: true } })
     * 
    **/
    findMany<T extends garageFindManyArgs>(
      args?: SelectSubset<T, garageFindManyArgs>
    ): CheckSelect<T, Promise<Array<garage>>, Promise<Array<garageGetPayload<T>>>>

    /**
     * Create a Garage.
     * @param {garageCreateArgs} args - Arguments to create a Garage.
     * @example
     * // Create one Garage
     * const Garage = await prisma.garage.create({
     *   data: {
     *     // ... data to create a Garage
     *   }
     * })
     * 
    **/
    create<T extends garageCreateArgs>(
      args: SelectSubset<T, garageCreateArgs>
    ): CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>>

    /**
     * Delete a Garage.
     * @param {garageDeleteArgs} args - Arguments to delete one Garage.
     * @example
     * // Delete one Garage
     * const Garage = await prisma.garage.delete({
     *   where: {
     *     // ... filter to delete one Garage
     *   }
     * })
     * 
    **/
    delete<T extends garageDeleteArgs>(
      args: SelectSubset<T, garageDeleteArgs>
    ): CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>>

    /**
     * Update one Garage.
     * @param {garageUpdateArgs} args - Arguments to update one Garage.
     * @example
     * // Update one Garage
     * const garage = await prisma.garage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends garageUpdateArgs>(
      args: SelectSubset<T, garageUpdateArgs>
    ): CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>>

    /**
     * Delete zero or more Garages.
     * @param {garageDeleteManyArgs} args - Arguments to filter Garages to delete.
     * @example
     * // Delete a few Garages
     * const { count } = await prisma.garage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends garageDeleteManyArgs>(
      args?: SelectSubset<T, garageDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Garages.
     * @param {garageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Garages
     * const garage = await prisma.garage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends garageUpdateManyArgs>(
      args: SelectSubset<T, garageUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Garage.
     * @param {garageUpsertArgs} args - Arguments to update or create a Garage.
     * @example
     * // Update or create a Garage
     * const garage = await prisma.garage.upsert({
     *   create: {
     *     // ... data to create a Garage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Garage we want to update
     *   }
     * })
    **/
    upsert<T extends garageUpsertArgs>(
      args: SelectSubset<T, garageUpsertArgs>
    ): CheckSelect<T, Prisma__garageClient<garage>, Prisma__garageClient<garageGetPayload<T>>>

    /**
     * Count the number of Garages.
     * @param {garageCountArgs} args - Arguments to filter Garages to count.
     * @example
     * // Count the number of Garages
     * const count = await prisma.garage.count({
     *   where: {
     *     // ... the filter for the Garages we want to count
     *   }
     * })
    **/
    count<T extends garageCountArgs>(
      args?: Subset<T, garageCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GarageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Garage.
     * @param {GarageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GarageAggregateArgs>(args: Subset<T, GarageAggregateArgs>): Promise<GetGarageAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for garage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__garageClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DeletedItemPart<T extends DeletedItemPartFindManyArgs = {}>(args?: Subset<T, DeletedItemPartFindManyArgs>): CheckSelect<T, Promise<Array<DeletedItemPart>>, Promise<Array<DeletedItemPartGetPayload<T>>>>;

    DeletedServiceExpense<T extends DeletedServiceExpenseFindManyArgs = {}>(args?: Subset<T, DeletedServiceExpenseFindManyArgs>): CheckSelect<T, Promise<Array<DeletedServiceExpense>>, Promise<Array<DeletedServiceExpenseGetPayload<T>>>>;

    serviceExpense<T extends serviceExpenseFindManyArgs = {}>(args?: Subset<T, serviceExpenseFindManyArgs>): CheckSelect<T, Promise<Array<serviceExpense>>, Promise<Array<serviceExpenseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * garage findUnique
   */
  export type garageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * Throw an Error if a garage can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which garage to fetch.
    **/
    where: garageWhereUniqueInput
  }


  /**
   * garage findFirst
   */
  export type garageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * Throw an Error if a garage can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which garage to fetch.
    **/
    where?: garageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of garages to fetch.
    **/
    orderBy?: Enumerable<garageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for garages.
    **/
    cursor?: garageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` garages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` garages.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of garages.
    **/
    distinct?: Enumerable<GarageScalarFieldEnum>
  }


  /**
   * garage findMany
   */
  export type garageFindManyArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * Filter, which garages to fetch.
    **/
    where?: garageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of garages to fetch.
    **/
    orderBy?: Enumerable<garageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing garages.
    **/
    cursor?: garageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` garages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` garages.
    **/
    skip?: number
    distinct?: Enumerable<GarageScalarFieldEnum>
  }


  /**
   * garage create
   */
  export type garageCreateArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * The data needed to create a garage.
    **/
    data: XOR<garageUncheckedCreateInput, garageCreateInput>
  }


  /**
   * garage update
   */
  export type garageUpdateArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * The data needed to update a garage.
    **/
    data: XOR<garageUncheckedUpdateInput, garageUpdateInput>
    /**
     * Choose, which garage to update.
    **/
    where: garageWhereUniqueInput
  }


  /**
   * garage updateMany
   */
  export type garageUpdateManyArgs = {
    data: XOR<garageUncheckedUpdateManyInput, garageUpdateManyMutationInput>
    where?: garageWhereInput
  }


  /**
   * garage upsert
   */
  export type garageUpsertArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * The filter to search for the garage to update in case it exists.
    **/
    where: garageWhereUniqueInput
    /**
     * In case the garage found by the `where` argument doesn't exist, create a new garage with this data.
    **/
    create: XOR<garageUncheckedCreateInput, garageCreateInput>
    /**
     * In case the garage was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<garageUncheckedUpdateInput, garageUpdateInput>
  }


  /**
   * garage delete
   */
  export type garageDeleteArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
    /**
     * Filter which garage to delete.
    **/
    where: garageWhereUniqueInput
  }


  /**
   * garage deleteMany
   */
  export type garageDeleteManyArgs = {
    where?: garageWhereInput
  }


  /**
   * garage without action
   */
  export type garageArgs = {
    /**
     * Select specific fields to fetch from the garage
    **/
    select?: garageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: garageInclude | null
  }



  /**
   * Model itemPart
   */


  export type AggregateItemPart = {
    count: ItemPartCountAggregateOutputType | null
    avg: ItemPartAvgAggregateOutputType | null
    sum: ItemPartSumAggregateOutputType | null
    min: ItemPartMinAggregateOutputType | null
    max: ItemPartMaxAggregateOutputType | null
  }

  export type ItemPartAvgAggregateOutputType = {
    partQuantity: number
    partPrice: number
    id: number | null
    supplierId: number | null
  }

  export type ItemPartSumAggregateOutputType = {
    partQuantity: number
    partPrice: number
    id: number | null
    supplierId: number | null
  }

  export type ItemPartMinAggregateOutputType = {
    itemPart: string | null
    partName: string | null
    partQuantity: number
    partPrice: number
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    supplierId: number | null
  }

  export type ItemPartMaxAggregateOutputType = {
    itemPart: string | null
    partName: string | null
    partQuantity: number
    partPrice: number
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    supplierId: number | null
  }

  export type ItemPartCountAggregateOutputType = {
    itemPart: number | null
    partName: number | null
    partQuantity: number
    partPrice: number
    createdAt: number | null
    updatedAt: number | null
    id: number | null
    supplierId: number | null
    _all: number
  }


  export type ItemPartAvgAggregateInputType = {
    partQuantity?: true
    partPrice?: true
    id?: true
    supplierId?: true
  }

  export type ItemPartSumAggregateInputType = {
    partQuantity?: true
    partPrice?: true
    id?: true
    supplierId?: true
  }

  export type ItemPartMinAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
  }

  export type ItemPartMaxAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
  }

  export type ItemPartCountAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
    _all?: true
  }

  export type ItemPartAggregateArgs = {
    /**
     * Filter which itemPart to aggregate.
    **/
    where?: itemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of itemParts to fetch.
    **/
    orderBy?: Enumerable<itemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: itemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemParts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemParts
    **/
    count?: true | ItemPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ItemPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ItemPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ItemPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ItemPartMaxAggregateInputType
  }

  export type GetItemPartAggregateType<T extends ItemPartAggregateArgs> = {
    [P in keyof T & keyof AggregateItemPart]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemPart[P]>
      : GetScalarType<T[P], AggregateItemPart[P]>
  }



  export type itemPartSelect = {
    itemPart?: boolean
    partName?: boolean
    partQuantity?: boolean
    partPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    supplierId?: boolean
    serviceExpense?: boolean | serviceExpenseArgs
    supplier?: boolean | supplierArgs
  }

  export type itemPartInclude = {
    serviceExpense?: boolean | serviceExpenseArgs
    supplier?: boolean | supplierArgs
  }

  export type itemPartGetPayload<
    S extends boolean | null | undefined | itemPartArgs,
    U = keyof S
      > = S extends true
        ? itemPart
    : S extends undefined
    ? never
    : S extends itemPartArgs | itemPartFindManyArgs
    ?'include' extends U
    ? itemPart  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'serviceExpense'
        ? serviceExpenseGetPayload<S['include'][P]> | null :
        P extends 'supplier'
        ? supplierGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof itemPart ?itemPart [P]
  : 
          P extends 'serviceExpense'
        ? serviceExpenseGetPayload<S['select'][P]> | null :
        P extends 'supplier'
        ? supplierGetPayload<S['select'][P]> | null : never
  } 
    : itemPart
  : itemPart


  type itemPartCountArgs = Merge<
    Omit<itemPartFindManyArgs, 'select' | 'include'> & {
      select?: ItemPartCountAggregateInputType | true
    }
  >

  export interface itemPartDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ItemPart that matches the filter.
     * @param {itemPartFindUniqueArgs} args - Arguments to find a ItemPart
     * @example
     * // Get one ItemPart
     * const itemPart = await prisma.itemPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends itemPartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, itemPartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'itemPart'> extends True ? CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>> : CheckSelect<T, Prisma__itemPartClient<itemPart | null >, Prisma__itemPartClient<itemPartGetPayload<T> | null >>

    /**
     * Find the first ItemPart that matches the filter.
     * @param {itemPartFindFirstArgs} args - Arguments to find a ItemPart
     * @example
     * // Get one ItemPart
     * const itemPart = await prisma.itemPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends itemPartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, itemPartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'itemPart'> extends True ? CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>> : CheckSelect<T, Prisma__itemPartClient<itemPart | null >, Prisma__itemPartClient<itemPartGetPayload<T> | null >>

    /**
     * Find zero or more ItemParts that matches the filter.
     * @param {itemPartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemParts
     * const itemParts = await prisma.itemPart.findMany()
     * 
     * // Get first 10 ItemParts
     * const itemParts = await prisma.itemPart.findMany({ take: 10 })
     * 
     * // Only select the `itemPart`
     * const itemPartWithItemPartOnly = await prisma.itemPart.findMany({ select: { itemPart: true } })
     * 
    **/
    findMany<T extends itemPartFindManyArgs>(
      args?: SelectSubset<T, itemPartFindManyArgs>
    ): CheckSelect<T, Promise<Array<itemPart>>, Promise<Array<itemPartGetPayload<T>>>>

    /**
     * Create a ItemPart.
     * @param {itemPartCreateArgs} args - Arguments to create a ItemPart.
     * @example
     * // Create one ItemPart
     * const ItemPart = await prisma.itemPart.create({
     *   data: {
     *     // ... data to create a ItemPart
     *   }
     * })
     * 
    **/
    create<T extends itemPartCreateArgs>(
      args: SelectSubset<T, itemPartCreateArgs>
    ): CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>>

    /**
     * Delete a ItemPart.
     * @param {itemPartDeleteArgs} args - Arguments to delete one ItemPart.
     * @example
     * // Delete one ItemPart
     * const ItemPart = await prisma.itemPart.delete({
     *   where: {
     *     // ... filter to delete one ItemPart
     *   }
     * })
     * 
    **/
    delete<T extends itemPartDeleteArgs>(
      args: SelectSubset<T, itemPartDeleteArgs>
    ): CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>>

    /**
     * Update one ItemPart.
     * @param {itemPartUpdateArgs} args - Arguments to update one ItemPart.
     * @example
     * // Update one ItemPart
     * const itemPart = await prisma.itemPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends itemPartUpdateArgs>(
      args: SelectSubset<T, itemPartUpdateArgs>
    ): CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>>

    /**
     * Delete zero or more ItemParts.
     * @param {itemPartDeleteManyArgs} args - Arguments to filter ItemParts to delete.
     * @example
     * // Delete a few ItemParts
     * const { count } = await prisma.itemPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends itemPartDeleteManyArgs>(
      args?: SelectSubset<T, itemPartDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ItemParts.
     * @param {itemPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemParts
     * const itemPart = await prisma.itemPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends itemPartUpdateManyArgs>(
      args: SelectSubset<T, itemPartUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ItemPart.
     * @param {itemPartUpsertArgs} args - Arguments to update or create a ItemPart.
     * @example
     * // Update or create a ItemPart
     * const itemPart = await prisma.itemPart.upsert({
     *   create: {
     *     // ... data to create a ItemPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemPart we want to update
     *   }
     * })
    **/
    upsert<T extends itemPartUpsertArgs>(
      args: SelectSubset<T, itemPartUpsertArgs>
    ): CheckSelect<T, Prisma__itemPartClient<itemPart>, Prisma__itemPartClient<itemPartGetPayload<T>>>

    /**
     * Count the number of ItemParts.
     * @param {itemPartCountArgs} args - Arguments to filter ItemParts to count.
     * @example
     * // Count the number of ItemParts
     * const count = await prisma.itemPart.count({
     *   where: {
     *     // ... the filter for the ItemParts we want to count
     *   }
     * })
    **/
    count<T extends itemPartCountArgs>(
      args?: Subset<T, itemPartCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemPart.
     * @param {ItemPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemPartAggregateArgs>(args: Subset<T, ItemPartAggregateArgs>): Promise<GetItemPartAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for itemPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__itemPartClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    serviceExpense<T extends serviceExpenseArgs = {}>(args?: Subset<T, serviceExpenseArgs>): CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense | null >, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T> | null >>;

    supplier<T extends supplierArgs = {}>(args?: Subset<T, supplierArgs>): CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * itemPart findUnique
   */
  export type itemPartFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * Throw an Error if a itemPart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which itemPart to fetch.
    **/
    where: itemPartWhereUniqueInput
  }


  /**
   * itemPart findFirst
   */
  export type itemPartFindFirstArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * Throw an Error if a itemPart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which itemPart to fetch.
    **/
    where?: itemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of itemParts to fetch.
    **/
    orderBy?: Enumerable<itemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemParts.
    **/
    cursor?: itemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemParts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of itemParts.
    **/
    distinct?: Enumerable<ItemPartScalarFieldEnum>
  }


  /**
   * itemPart findMany
   */
  export type itemPartFindManyArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * Filter, which itemParts to fetch.
    **/
    where?: itemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of itemParts to fetch.
    **/
    orderBy?: Enumerable<itemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemParts.
    **/
    cursor?: itemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemParts.
    **/
    skip?: number
    distinct?: Enumerable<ItemPartScalarFieldEnum>
  }


  /**
   * itemPart create
   */
  export type itemPartCreateArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * The data needed to create a itemPart.
    **/
    data: XOR<itemPartUncheckedCreateInput, itemPartCreateInput>
  }


  /**
   * itemPart update
   */
  export type itemPartUpdateArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * The data needed to update a itemPart.
    **/
    data: XOR<itemPartUncheckedUpdateInput, itemPartUpdateInput>
    /**
     * Choose, which itemPart to update.
    **/
    where: itemPartWhereUniqueInput
  }


  /**
   * itemPart updateMany
   */
  export type itemPartUpdateManyArgs = {
    data: XOR<itemPartUncheckedUpdateManyInput, itemPartUpdateManyMutationInput>
    where?: itemPartWhereInput
  }


  /**
   * itemPart upsert
   */
  export type itemPartUpsertArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * The filter to search for the itemPart to update in case it exists.
    **/
    where: itemPartWhereUniqueInput
    /**
     * In case the itemPart found by the `where` argument doesn't exist, create a new itemPart with this data.
    **/
    create: XOR<itemPartUncheckedCreateInput, itemPartCreateInput>
    /**
     * In case the itemPart was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<itemPartUncheckedUpdateInput, itemPartUpdateInput>
  }


  /**
   * itemPart delete
   */
  export type itemPartDeleteArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
    /**
     * Filter which itemPart to delete.
    **/
    where: itemPartWhereUniqueInput
  }


  /**
   * itemPart deleteMany
   */
  export type itemPartDeleteManyArgs = {
    where?: itemPartWhereInput
  }


  /**
   * itemPart without action
   */
  export type itemPartArgs = {
    /**
     * Select specific fields to fetch from the itemPart
    **/
    select?: itemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: itemPartInclude | null
  }



  /**
   * Model part
   */


  export type AggregatePart = {
    count: PartCountAggregateOutputType | null
    avg: PartAvgAggregateOutputType | null
    sum: PartSumAggregateOutputType | null
    min: PartMinAggregateOutputType | null
    max: PartMaxAggregateOutputType | null
  }

  export type PartAvgAggregateOutputType = {
    partId: number
  }

  export type PartSumAggregateOutputType = {
    partId: number
  }

  export type PartMinAggregateOutputType = {
    partId: number
    partName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartMaxAggregateOutputType = {
    partId: number
    partName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartCountAggregateOutputType = {
    partId: number
    partName: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type PartAvgAggregateInputType = {
    partId?: true
  }

  export type PartSumAggregateInputType = {
    partId?: true
  }

  export type PartMinAggregateInputType = {
    partId?: true
    partName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartMaxAggregateInputType = {
    partId?: true
    partName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartCountAggregateInputType = {
    partId?: true
    partName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartAggregateArgs = {
    /**
     * Filter which part to aggregate.
    **/
    where?: partWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of parts to fetch.
    **/
    orderBy?: Enumerable<partOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: partWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parts
    **/
    count?: true | PartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PartMaxAggregateInputType
  }

  export type GetPartAggregateType<T extends PartAggregateArgs> = {
    [P in keyof T & keyof AggregatePart]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePart[P]>
      : GetScalarType<T[P], AggregatePart[P]>
  }



  export type partSelect = {
    partId?: boolean
    partName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type partGetPayload<
    S extends boolean | null | undefined | partArgs,
    U = keyof S
      > = S extends true
        ? part
    : S extends undefined
    ? never
    : S extends partArgs | partFindManyArgs
    ?'include' extends U
    ? part 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof part ?part [P]
  : 
     never
  } 
    : part
  : part


  type partCountArgs = Merge<
    Omit<partFindManyArgs, 'select' | 'include'> & {
      select?: PartCountAggregateInputType | true
    }
  >

  export interface partDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Part that matches the filter.
     * @param {partFindUniqueArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends partFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, partFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'part'> extends True ? CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>> : CheckSelect<T, Prisma__partClient<part | null >, Prisma__partClient<partGetPayload<T> | null >>

    /**
     * Find the first Part that matches the filter.
     * @param {partFindFirstArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends partFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, partFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'part'> extends True ? CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>> : CheckSelect<T, Prisma__partClient<part | null >, Prisma__partClient<partGetPayload<T> | null >>

    /**
     * Find zero or more Parts that matches the filter.
     * @param {partFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.part.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.part.findMany({ take: 10 })
     * 
     * // Only select the `partId`
     * const partWithPartIdOnly = await prisma.part.findMany({ select: { partId: true } })
     * 
    **/
    findMany<T extends partFindManyArgs>(
      args?: SelectSubset<T, partFindManyArgs>
    ): CheckSelect<T, Promise<Array<part>>, Promise<Array<partGetPayload<T>>>>

    /**
     * Create a Part.
     * @param {partCreateArgs} args - Arguments to create a Part.
     * @example
     * // Create one Part
     * const Part = await prisma.part.create({
     *   data: {
     *     // ... data to create a Part
     *   }
     * })
     * 
    **/
    create<T extends partCreateArgs>(
      args: SelectSubset<T, partCreateArgs>
    ): CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>>

    /**
     * Delete a Part.
     * @param {partDeleteArgs} args - Arguments to delete one Part.
     * @example
     * // Delete one Part
     * const Part = await prisma.part.delete({
     *   where: {
     *     // ... filter to delete one Part
     *   }
     * })
     * 
    **/
    delete<T extends partDeleteArgs>(
      args: SelectSubset<T, partDeleteArgs>
    ): CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>>

    /**
     * Update one Part.
     * @param {partUpdateArgs} args - Arguments to update one Part.
     * @example
     * // Update one Part
     * const part = await prisma.part.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends partUpdateArgs>(
      args: SelectSubset<T, partUpdateArgs>
    ): CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>>

    /**
     * Delete zero or more Parts.
     * @param {partDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.part.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends partDeleteManyArgs>(
      args?: SelectSubset<T, partDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Parts.
     * @param {partUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends partUpdateManyArgs>(
      args: SelectSubset<T, partUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Part.
     * @param {partUpsertArgs} args - Arguments to update or create a Part.
     * @example
     * // Update or create a Part
     * const part = await prisma.part.upsert({
     *   create: {
     *     // ... data to create a Part
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Part we want to update
     *   }
     * })
    **/
    upsert<T extends partUpsertArgs>(
      args: SelectSubset<T, partUpsertArgs>
    ): CheckSelect<T, Prisma__partClient<part>, Prisma__partClient<partGetPayload<T>>>

    /**
     * Count the number of Parts.
     * @param {partCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.part.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends partCountArgs>(
      args?: Subset<T, partCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Part.
     * @param {PartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartAggregateArgs>(args: Subset<T, PartAggregateArgs>): Promise<GetPartAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for part.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__partClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * part findUnique
   */
  export type partFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * Throw an Error if a part can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which part to fetch.
    **/
    where: partWhereUniqueInput
  }


  /**
   * part findFirst
   */
  export type partFindFirstArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * Throw an Error if a part can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which part to fetch.
    **/
    where?: partWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of parts to fetch.
    **/
    orderBy?: Enumerable<partOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parts.
    **/
    cursor?: partWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of parts.
    **/
    distinct?: Enumerable<PartScalarFieldEnum>
  }


  /**
   * part findMany
   */
  export type partFindManyArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * Filter, which parts to fetch.
    **/
    where?: partWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of parts to fetch.
    **/
    orderBy?: Enumerable<partOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parts.
    **/
    cursor?: partWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
    **/
    skip?: number
    distinct?: Enumerable<PartScalarFieldEnum>
  }


  /**
   * part create
   */
  export type partCreateArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * The data needed to create a part.
    **/
    data: XOR<partUncheckedCreateInput, partCreateInput>
  }


  /**
   * part update
   */
  export type partUpdateArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * The data needed to update a part.
    **/
    data: XOR<partUncheckedUpdateInput, partUpdateInput>
    /**
     * Choose, which part to update.
    **/
    where: partWhereUniqueInput
  }


  /**
   * part updateMany
   */
  export type partUpdateManyArgs = {
    data: XOR<partUncheckedUpdateManyInput, partUpdateManyMutationInput>
    where?: partWhereInput
  }


  /**
   * part upsert
   */
  export type partUpsertArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * The filter to search for the part to update in case it exists.
    **/
    where: partWhereUniqueInput
    /**
     * In case the part found by the `where` argument doesn't exist, create a new part with this data.
    **/
    create: XOR<partUncheckedCreateInput, partCreateInput>
    /**
     * In case the part was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<partUncheckedUpdateInput, partUpdateInput>
  }


  /**
   * part delete
   */
  export type partDeleteArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
    /**
     * Filter which part to delete.
    **/
    where: partWhereUniqueInput
  }


  /**
   * part deleteMany
   */
  export type partDeleteManyArgs = {
    where?: partWhereInput
  }


  /**
   * part without action
   */
  export type partArgs = {
    /**
     * Select specific fields to fetch from the part
    **/
    select?: partSelect | null
  }



  /**
   * Model serviceExpense
   */


  export type AggregateServiceExpense = {
    count: ServiceExpenseCountAggregateOutputType | null
    avg: ServiceExpenseAvgAggregateOutputType | null
    sum: ServiceExpenseSumAggregateOutputType | null
    min: ServiceExpenseMinAggregateOutputType | null
    max: ServiceExpenseMaxAggregateOutputType | null
  }

  export type ServiceExpenseAvgAggregateOutputType = {
    id: number
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    vehicleId: number | null
    garageId: number | null
  }

  export type ServiceExpenseSumAggregateOutputType = {
    id: number
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    vehicleId: number | null
    garageId: number | null
  }

  export type ServiceExpenseMinAggregateOutputType = {
    id: number
    invoiceNumber: string | null
    serviceDescription: string | null
    serviceDate: Date | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleId: number | null
    garageId: number | null
  }

  export type ServiceExpenseMaxAggregateOutputType = {
    id: number
    invoiceNumber: string | null
    serviceDescription: string | null
    serviceDate: Date | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleId: number | null
    garageId: number | null
  }

  export type ServiceExpenseCountAggregateOutputType = {
    id: number
    invoiceNumber: number | null
    serviceDescription: number | null
    serviceDate: number | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: number | null
    updatedAt: number | null
    vehicleId: number | null
    garageId: number | null
    _all: number
  }


  export type ServiceExpenseAvgAggregateInputType = {
    id?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    vehicleId?: true
    garageId?: true
  }

  export type ServiceExpenseSumAggregateInputType = {
    id?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    vehicleId?: true
    garageId?: true
  }

  export type ServiceExpenseMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
  }

  export type ServiceExpenseMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
  }

  export type ServiceExpenseCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
    _all?: true
  }

  export type ServiceExpenseAggregateArgs = {
    /**
     * Filter which serviceExpense to aggregate.
    **/
    where?: serviceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of serviceExpenses to fetch.
    **/
    orderBy?: Enumerable<serviceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: serviceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceExpenses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceExpenses
    **/
    count?: true | ServiceExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ServiceExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ServiceExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ServiceExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ServiceExpenseMaxAggregateInputType
  }

  export type GetServiceExpenseAggregateType<T extends ServiceExpenseAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceExpense]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceExpense[P]>
      : GetScalarType<T[P], AggregateServiceExpense[P]>
  }



  export type serviceExpenseSelect = {
    id?: boolean
    invoiceNumber?: boolean
    serviceDescription?: boolean
    serviceDate?: boolean
    serviceCost?: boolean
    totalCost?: boolean
    purchaseID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleId?: boolean
    garageId?: boolean
    garage?: boolean | garageArgs
    vehicle?: boolean | vehicleArgs
    itemPart?: boolean | itemPartFindManyArgs
  }

  export type serviceExpenseInclude = {
    garage?: boolean | garageArgs
    vehicle?: boolean | vehicleArgs
    itemPart?: boolean | itemPartFindManyArgs
  }

  export type serviceExpenseGetPayload<
    S extends boolean | null | undefined | serviceExpenseArgs,
    U = keyof S
      > = S extends true
        ? serviceExpense
    : S extends undefined
    ? never
    : S extends serviceExpenseArgs | serviceExpenseFindManyArgs
    ?'include' extends U
    ? serviceExpense  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'garage'
        ? garageGetPayload<S['include'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['include'][P]> | null :
        P extends 'itemPart'
        ? Array < itemPartGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof serviceExpense ?serviceExpense [P]
  : 
          P extends 'garage'
        ? garageGetPayload<S['select'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['select'][P]> | null :
        P extends 'itemPart'
        ? Array < itemPartGetPayload<S['select'][P]>>  : never
  } 
    : serviceExpense
  : serviceExpense


  type serviceExpenseCountArgs = Merge<
    Omit<serviceExpenseFindManyArgs, 'select' | 'include'> & {
      select?: ServiceExpenseCountAggregateInputType | true
    }
  >

  export interface serviceExpenseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ServiceExpense that matches the filter.
     * @param {serviceExpenseFindUniqueArgs} args - Arguments to find a ServiceExpense
     * @example
     * // Get one ServiceExpense
     * const serviceExpense = await prisma.serviceExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviceExpenseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviceExpenseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'serviceExpense'> extends True ? CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>> : CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense | null >, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T> | null >>

    /**
     * Find the first ServiceExpense that matches the filter.
     * @param {serviceExpenseFindFirstArgs} args - Arguments to find a ServiceExpense
     * @example
     * // Get one ServiceExpense
     * const serviceExpense = await prisma.serviceExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviceExpenseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviceExpenseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'serviceExpense'> extends True ? CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>> : CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense | null >, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T> | null >>

    /**
     * Find zero or more ServiceExpenses that matches the filter.
     * @param {serviceExpenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceExpenses
     * const serviceExpenses = await prisma.serviceExpense.findMany()
     * 
     * // Get first 10 ServiceExpenses
     * const serviceExpenses = await prisma.serviceExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceExpenseWithIdOnly = await prisma.serviceExpense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends serviceExpenseFindManyArgs>(
      args?: SelectSubset<T, serviceExpenseFindManyArgs>
    ): CheckSelect<T, Promise<Array<serviceExpense>>, Promise<Array<serviceExpenseGetPayload<T>>>>

    /**
     * Create a ServiceExpense.
     * @param {serviceExpenseCreateArgs} args - Arguments to create a ServiceExpense.
     * @example
     * // Create one ServiceExpense
     * const ServiceExpense = await prisma.serviceExpense.create({
     *   data: {
     *     // ... data to create a ServiceExpense
     *   }
     * })
     * 
    **/
    create<T extends serviceExpenseCreateArgs>(
      args: SelectSubset<T, serviceExpenseCreateArgs>
    ): CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>>

    /**
     * Delete a ServiceExpense.
     * @param {serviceExpenseDeleteArgs} args - Arguments to delete one ServiceExpense.
     * @example
     * // Delete one ServiceExpense
     * const ServiceExpense = await prisma.serviceExpense.delete({
     *   where: {
     *     // ... filter to delete one ServiceExpense
     *   }
     * })
     * 
    **/
    delete<T extends serviceExpenseDeleteArgs>(
      args: SelectSubset<T, serviceExpenseDeleteArgs>
    ): CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>>

    /**
     * Update one ServiceExpense.
     * @param {serviceExpenseUpdateArgs} args - Arguments to update one ServiceExpense.
     * @example
     * // Update one ServiceExpense
     * const serviceExpense = await prisma.serviceExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviceExpenseUpdateArgs>(
      args: SelectSubset<T, serviceExpenseUpdateArgs>
    ): CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>>

    /**
     * Delete zero or more ServiceExpenses.
     * @param {serviceExpenseDeleteManyArgs} args - Arguments to filter ServiceExpenses to delete.
     * @example
     * // Delete a few ServiceExpenses
     * const { count } = await prisma.serviceExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviceExpenseDeleteManyArgs>(
      args?: SelectSubset<T, serviceExpenseDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ServiceExpenses.
     * @param {serviceExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceExpenses
     * const serviceExpense = await prisma.serviceExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviceExpenseUpdateManyArgs>(
      args: SelectSubset<T, serviceExpenseUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ServiceExpense.
     * @param {serviceExpenseUpsertArgs} args - Arguments to update or create a ServiceExpense.
     * @example
     * // Update or create a ServiceExpense
     * const serviceExpense = await prisma.serviceExpense.upsert({
     *   create: {
     *     // ... data to create a ServiceExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceExpense we want to update
     *   }
     * })
    **/
    upsert<T extends serviceExpenseUpsertArgs>(
      args: SelectSubset<T, serviceExpenseUpsertArgs>
    ): CheckSelect<T, Prisma__serviceExpenseClient<serviceExpense>, Prisma__serviceExpenseClient<serviceExpenseGetPayload<T>>>

    /**
     * Count the number of ServiceExpenses.
     * @param {serviceExpenseCountArgs} args - Arguments to filter ServiceExpenses to count.
     * @example
     * // Count the number of ServiceExpenses
     * const count = await prisma.serviceExpense.count({
     *   where: {
     *     // ... the filter for the ServiceExpenses we want to count
     *   }
     * })
    **/
    count<T extends serviceExpenseCountArgs>(
      args?: Subset<T, serviceExpenseCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceExpense.
     * @param {ServiceExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceExpenseAggregateArgs>(args: Subset<T, ServiceExpenseAggregateArgs>): Promise<GetServiceExpenseAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviceExpenseClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    garage<T extends garageArgs = {}>(args?: Subset<T, garageArgs>): CheckSelect<T, Prisma__garageClient<garage | null >, Prisma__garageClient<garageGetPayload<T> | null >>;

    vehicle<T extends vehicleArgs = {}>(args?: Subset<T, vehicleArgs>): CheckSelect<T, Prisma__vehicleClient<vehicle | null >, Prisma__vehicleClient<vehicleGetPayload<T> | null >>;

    itemPart<T extends itemPartFindManyArgs = {}>(args?: Subset<T, itemPartFindManyArgs>): CheckSelect<T, Promise<Array<itemPart>>, Promise<Array<itemPartGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * serviceExpense findUnique
   */
  export type serviceExpenseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * Throw an Error if a serviceExpense can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which serviceExpense to fetch.
    **/
    where: serviceExpenseWhereUniqueInput
  }


  /**
   * serviceExpense findFirst
   */
  export type serviceExpenseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * Throw an Error if a serviceExpense can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which serviceExpense to fetch.
    **/
    where?: serviceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of serviceExpenses to fetch.
    **/
    orderBy?: Enumerable<serviceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceExpenses.
    **/
    cursor?: serviceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceExpenses.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of serviceExpenses.
    **/
    distinct?: Enumerable<ServiceExpenseScalarFieldEnum>
  }


  /**
   * serviceExpense findMany
   */
  export type serviceExpenseFindManyArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * Filter, which serviceExpenses to fetch.
    **/
    where?: serviceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of serviceExpenses to fetch.
    **/
    orderBy?: Enumerable<serviceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceExpenses.
    **/
    cursor?: serviceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceExpenses.
    **/
    skip?: number
    distinct?: Enumerable<ServiceExpenseScalarFieldEnum>
  }


  /**
   * serviceExpense create
   */
  export type serviceExpenseCreateArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * The data needed to create a serviceExpense.
    **/
    data: XOR<serviceExpenseUncheckedCreateInput, serviceExpenseCreateInput>
  }


  /**
   * serviceExpense update
   */
  export type serviceExpenseUpdateArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * The data needed to update a serviceExpense.
    **/
    data: XOR<serviceExpenseUncheckedUpdateInput, serviceExpenseUpdateInput>
    /**
     * Choose, which serviceExpense to update.
    **/
    where: serviceExpenseWhereUniqueInput
  }


  /**
   * serviceExpense updateMany
   */
  export type serviceExpenseUpdateManyArgs = {
    data: XOR<serviceExpenseUncheckedUpdateManyInput, serviceExpenseUpdateManyMutationInput>
    where?: serviceExpenseWhereInput
  }


  /**
   * serviceExpense upsert
   */
  export type serviceExpenseUpsertArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * The filter to search for the serviceExpense to update in case it exists.
    **/
    where: serviceExpenseWhereUniqueInput
    /**
     * In case the serviceExpense found by the `where` argument doesn't exist, create a new serviceExpense with this data.
    **/
    create: XOR<serviceExpenseUncheckedCreateInput, serviceExpenseCreateInput>
    /**
     * In case the serviceExpense was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<serviceExpenseUncheckedUpdateInput, serviceExpenseUpdateInput>
  }


  /**
   * serviceExpense delete
   */
  export type serviceExpenseDeleteArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
    /**
     * Filter which serviceExpense to delete.
    **/
    where: serviceExpenseWhereUniqueInput
  }


  /**
   * serviceExpense deleteMany
   */
  export type serviceExpenseDeleteManyArgs = {
    where?: serviceExpenseWhereInput
  }


  /**
   * serviceExpense without action
   */
  export type serviceExpenseArgs = {
    /**
     * Select specific fields to fetch from the serviceExpense
    **/
    select?: serviceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: serviceExpenseInclude | null
  }



  /**
   * Model supplier
   */


  export type AggregateSupplier = {
    count: SupplierCountAggregateOutputType | null
    avg: SupplierAvgAggregateOutputType | null
    sum: SupplierSumAggregateOutputType | null
    min: SupplierMinAggregateOutputType | null
    max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    supplierId: number
  }

  export type SupplierSumAggregateOutputType = {
    supplierId: number
  }

  export type SupplierMinAggregateOutputType = {
    supplierId: number
    supplierName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    supplierId: number
    supplierName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    supplierId: number
    supplierName: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    supplierId?: true
  }

  export type SupplierSumAggregateInputType = {
    supplierId?: true
  }

  export type SupplierMinAggregateInputType = {
    supplierId?: true
    supplierName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    supplierId?: true
    supplierName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    supplierId?: true
    supplierName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs = {
    /**
     * Filter which supplier to aggregate.
    **/
    where?: supplierWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<supplierOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
    [P in keyof T & keyof AggregateSupplier]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }



  export type supplierSelect = {
    supplierId?: boolean
    supplierName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DeletedItemPart?: boolean | DeletedItemPartFindManyArgs
    itemPart?: boolean | itemPartFindManyArgs
  }

  export type supplierInclude = {
    DeletedItemPart?: boolean | DeletedItemPartFindManyArgs
    itemPart?: boolean | itemPartFindManyArgs
  }

  export type supplierGetPayload<
    S extends boolean | null | undefined | supplierArgs,
    U = keyof S
      > = S extends true
        ? supplier
    : S extends undefined
    ? never
    : S extends supplierArgs | supplierFindManyArgs
    ?'include' extends U
    ? supplier  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'DeletedItemPart'
        ? Array < DeletedItemPartGetPayload<S['include'][P]>>  :
        P extends 'itemPart'
        ? Array < itemPartGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof supplier ?supplier [P]
  : 
          P extends 'DeletedItemPart'
        ? Array < DeletedItemPartGetPayload<S['select'][P]>>  :
        P extends 'itemPart'
        ? Array < itemPartGetPayload<S['select'][P]>>  : never
  } 
    : supplier
  : supplier


  type supplierCountArgs = Merge<
    Omit<supplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }
  >

  export interface supplierDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, supplierFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'supplier'> extends True ? CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>> : CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>

    /**
     * Find the first Supplier that matches the filter.
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, supplierFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'supplier'> extends True ? CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>> : CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>

    /**
     * Find zero or more Suppliers that matches the filter.
     * @param {supplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `supplierId`
     * const supplierWithSupplierIdOnly = await prisma.supplier.findMany({ select: { supplierId: true } })
     * 
    **/
    findMany<T extends supplierFindManyArgs>(
      args?: SelectSubset<T, supplierFindManyArgs>
    ): CheckSelect<T, Promise<Array<supplier>>, Promise<Array<supplierGetPayload<T>>>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends supplierCreateArgs>(
      args: SelectSubset<T, supplierCreateArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends supplierDeleteArgs>(
      args: SelectSubset<T, supplierDeleteArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierUpdateArgs>(
      args: SelectSubset<T, supplierUpdateArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierDeleteManyArgs>(
      args?: SelectSubset<T, supplierDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierUpdateManyArgs>(
      args: SelectSubset<T, supplierUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends supplierUpsertArgs>(
      args: SelectSubset<T, supplierUpsertArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Count the number of Suppliers.
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Promise<GetSupplierAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__supplierClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DeletedItemPart<T extends DeletedItemPartFindManyArgs = {}>(args?: Subset<T, DeletedItemPartFindManyArgs>): CheckSelect<T, Promise<Array<DeletedItemPart>>, Promise<Array<DeletedItemPartGetPayload<T>>>>;

    itemPart<T extends itemPartFindManyArgs = {}>(args?: Subset<T, itemPartFindManyArgs>): CheckSelect<T, Promise<Array<itemPart>>, Promise<Array<itemPartGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * Throw an Error if a supplier can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which supplier to fetch.
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * Throw an Error if a supplier can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which supplier to fetch.
    **/
    where?: supplierWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<supplierOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of suppliers.
    **/
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * supplier findMany
   */
  export type supplierFindManyArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * Filter, which suppliers to fetch.
    **/
    where?: supplierWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<supplierOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * supplier create
   */
  export type supplierCreateArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * The data needed to create a supplier.
    **/
    data: XOR<supplierUncheckedCreateInput, supplierCreateInput>
  }


  /**
   * supplier update
   */
  export type supplierUpdateArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * The data needed to update a supplier.
    **/
    data: XOR<supplierUncheckedUpdateInput, supplierUpdateInput>
    /**
     * Choose, which supplier to update.
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs = {
    data: XOR<supplierUncheckedUpdateManyInput, supplierUpdateManyMutationInput>
    where?: supplierWhereInput
  }


  /**
   * supplier upsert
   */
  export type supplierUpsertArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * The filter to search for the supplier to update in case it exists.
    **/
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
    **/
    create: XOR<supplierUncheckedCreateInput, supplierCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<supplierUncheckedUpdateInput, supplierUpdateInput>
  }


  /**
   * supplier delete
   */
  export type supplierDeleteArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
    /**
     * Filter which supplier to delete.
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs = {
    where?: supplierWhereInput
  }


  /**
   * supplier without action
   */
  export type supplierArgs = {
    /**
     * Select specific fields to fetch from the supplier
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: supplierInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    count: UsersCountAggregateOutputType | null
    avg: UsersAvgAggregateOutputType | null
    sum: UsersSumAggregateOutputType | null
    min: UsersMinAggregateOutputType | null
    max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    userId: number
  }

  export type UsersSumAggregateOutputType = {
    userId: number
  }

  export type UsersMinAggregateOutputType = {
    userId: number
    username: string | null
    email: string | null
    isAdmin: string | null
    password: string | null
  }

  export type UsersMaxAggregateOutputType = {
    userId: number
    username: string | null
    email: string | null
    isAdmin: string | null
    password: string | null
  }

  export type UsersCountAggregateOutputType = {
    userId: number
    username: number | null
    email: number | null
    isAdmin: number | null
    password: number | null
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    userId?: true
  }

  export type UsersSumAggregateInputType = {
    userId?: true
  }

  export type UsersMinAggregateInputType = {
    userId?: true
    username?: true
    email?: true
    isAdmin?: true
    password?: true
  }

  export type UsersMaxAggregateInputType = {
    userId?: true
    username?: true
    email?: true
    isAdmin?: true
    password?: true
  }

  export type UsersCountAggregateInputType = {
    userId?: true
    username?: true
    email?: true
    isAdmin?: true
    password?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }



  export type usersSelect = {
    userId?: boolean
    username?: boolean
    email?: boolean
    isAdmin?: boolean
    password?: boolean
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof users ?users [P]
  : 
     never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersWithUserIdOnly = await prisma.users.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Users.
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Promise<GetUsersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Throw an Error if a users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Throw an Error if a users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of users.
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * The data needed to create a users.
    **/
    data: XOR<usersUncheckedCreateInput, usersCreateInput>
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * The data needed to update a users.
    **/
    data: XOR<usersUncheckedUpdateInput, usersUpdateInput>
    /**
     * Choose, which users to update.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    data: XOR<usersUncheckedUpdateManyInput, usersUpdateManyMutationInput>
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * The filter to search for the users to update in case it exists.
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
    **/
    create: XOR<usersUncheckedCreateInput, usersCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<usersUncheckedUpdateInput, usersUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Filter which users to delete.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
  }



  /**
   * Model vehicle
   */


  export type AggregateVehicle = {
    count: VehicleCountAggregateOutputType | null
    avg: VehicleAvgAggregateOutputType | null
    sum: VehicleSumAggregateOutputType | null
    min: VehicleMinAggregateOutputType | null
    max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    vehicleId: number
    modelYear: number
    chasisNubmer: number
    purchaseMileAge: number
    departmentId: number | null
  }

  export type VehicleSumAggregateOutputType = {
    vehicleId: number
    modelYear: number
    chasisNubmer: number
    purchaseMileAge: number
    departmentId: number | null
  }

  export type VehicleMinAggregateOutputType = {
    vehicleId: number
    plateNumber: string | null
    model: string | null
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | null
    purchaseMileAge: number
    disposalDate: Date | null
    vehicleStatus: string | null
    departmentId: number | null
    location: string | null
    reason: string | null
  }

  export type VehicleMaxAggregateOutputType = {
    vehicleId: number
    plateNumber: string | null
    model: string | null
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | null
    purchaseMileAge: number
    disposalDate: Date | null
    vehicleStatus: string | null
    departmentId: number | null
    location: string | null
    reason: string | null
  }

  export type VehicleCountAggregateOutputType = {
    vehicleId: number
    plateNumber: number | null
    model: number | null
    modelYear: number
    chasisNubmer: number
    purchaseDate: number | null
    purchaseMileAge: number
    disposalDate: number | null
    vehicleStatus: number | null
    departmentId: number | null
    location: number | null
    reason: number | null
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    vehicleId?: true
    modelYear?: true
    chasisNubmer?: true
    purchaseMileAge?: true
    departmentId?: true
  }

  export type VehicleSumAggregateInputType = {
    vehicleId?: true
    modelYear?: true
    chasisNubmer?: true
    purchaseMileAge?: true
    departmentId?: true
  }

  export type VehicleMinAggregateInputType = {
    vehicleId?: true
    plateNumber?: true
    model?: true
    modelYear?: true
    chasisNubmer?: true
    purchaseDate?: true
    purchaseMileAge?: true
    disposalDate?: true
    vehicleStatus?: true
    departmentId?: true
    location?: true
    reason?: true
  }

  export type VehicleMaxAggregateInputType = {
    vehicleId?: true
    plateNumber?: true
    model?: true
    modelYear?: true
    chasisNubmer?: true
    purchaseDate?: true
    purchaseMileAge?: true
    disposalDate?: true
    vehicleStatus?: true
    departmentId?: true
    location?: true
    reason?: true
  }

  export type VehicleCountAggregateInputType = {
    vehicleId?: true
    plateNumber?: true
    model?: true
    modelYear?: true
    chasisNubmer?: true
    purchaseDate?: true
    purchaseMileAge?: true
    disposalDate?: true
    vehicleStatus?: true
    departmentId?: true
    location?: true
    reason?: true
    _all?: true
  }

  export type VehicleAggregateArgs = {
    /**
     * Filter which vehicle to aggregate.
    **/
    where?: vehicleWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of vehicles to fetch.
    **/
    orderBy?: Enumerable<vehicleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
    [P in keyof T & keyof AggregateVehicle]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }



  export type vehicleSelect = {
    vehicleId?: boolean
    plateNumber?: boolean
    model?: boolean
    modelYear?: boolean
    chasisNubmer?: boolean
    purchaseDate?: boolean
    purchaseMileAge?: boolean
    disposalDate?: boolean
    vehicleStatus?: boolean
    departmentId?: boolean
    location?: boolean
    reason?: boolean
    department?: boolean | departmentArgs
    DeletedServiceExpense?: boolean | DeletedServiceExpenseFindManyArgs
    driving?: boolean | drivingFindManyArgs
    serviceExpense?: boolean | serviceExpenseFindManyArgs
  }

  export type vehicleInclude = {
    department?: boolean | departmentArgs
    DeletedServiceExpense?: boolean | DeletedServiceExpenseFindManyArgs
    driving?: boolean | drivingFindManyArgs
    serviceExpense?: boolean | serviceExpenseFindManyArgs
  }

  export type vehicleGetPayload<
    S extends boolean | null | undefined | vehicleArgs,
    U = keyof S
      > = S extends true
        ? vehicle
    : S extends undefined
    ? never
    : S extends vehicleArgs | vehicleFindManyArgs
    ?'include' extends U
    ? vehicle  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'department'
        ? departmentGetPayload<S['include'][P]> | null :
        P extends 'DeletedServiceExpense'
        ? Array < DeletedServiceExpenseGetPayload<S['include'][P]>>  :
        P extends 'driving'
        ? Array < drivingGetPayload<S['include'][P]>>  :
        P extends 'serviceExpense'
        ? Array < serviceExpenseGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof vehicle ?vehicle [P]
  : 
          P extends 'department'
        ? departmentGetPayload<S['select'][P]> | null :
        P extends 'DeletedServiceExpense'
        ? Array < DeletedServiceExpenseGetPayload<S['select'][P]>>  :
        P extends 'driving'
        ? Array < drivingGetPayload<S['select'][P]>>  :
        P extends 'serviceExpense'
        ? Array < serviceExpenseGetPayload<S['select'][P]>>  : never
  } 
    : vehicle
  : vehicle


  type vehicleCountArgs = Merge<
    Omit<vehicleFindManyArgs, 'select' | 'include'> & {
      select?: VehicleCountAggregateInputType | true
    }
  >

  export interface vehicleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {vehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vehicleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vehicleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vehicle'> extends True ? CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>> : CheckSelect<T, Prisma__vehicleClient<vehicle | null >, Prisma__vehicleClient<vehicleGetPayload<T> | null >>

    /**
     * Find the first Vehicle that matches the filter.
     * @param {vehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vehicleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vehicleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vehicle'> extends True ? CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>> : CheckSelect<T, Prisma__vehicleClient<vehicle | null >, Prisma__vehicleClient<vehicleGetPayload<T> | null >>

    /**
     * Find zero or more Vehicles that matches the filter.
     * @param {vehicleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `vehicleId`
     * const vehicleWithVehicleIdOnly = await prisma.vehicle.findMany({ select: { vehicleId: true } })
     * 
    **/
    findMany<T extends vehicleFindManyArgs>(
      args?: SelectSubset<T, vehicleFindManyArgs>
    ): CheckSelect<T, Promise<Array<vehicle>>, Promise<Array<vehicleGetPayload<T>>>>

    /**
     * Create a Vehicle.
     * @param {vehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
    **/
    create<T extends vehicleCreateArgs>(
      args: SelectSubset<T, vehicleCreateArgs>
    ): CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>>

    /**
     * Delete a Vehicle.
     * @param {vehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
    **/
    delete<T extends vehicleDeleteArgs>(
      args: SelectSubset<T, vehicleDeleteArgs>
    ): CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>>

    /**
     * Update one Vehicle.
     * @param {vehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vehicleUpdateArgs>(
      args: SelectSubset<T, vehicleUpdateArgs>
    ): CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>>

    /**
     * Delete zero or more Vehicles.
     * @param {vehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vehicleDeleteManyArgs>(
      args?: SelectSubset<T, vehicleDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * @param {vehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vehicleUpdateManyArgs>(
      args: SelectSubset<T, vehicleUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {vehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
    **/
    upsert<T extends vehicleUpsertArgs>(
      args: SelectSubset<T, vehicleUpsertArgs>
    ): CheckSelect<T, Prisma__vehicleClient<vehicle>, Prisma__vehicleClient<vehicleGetPayload<T>>>

    /**
     * Count the number of Vehicles.
     * @param {vehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehicleCountArgs>(
      args?: Subset<T, vehicleCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Promise<GetVehicleAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vehicleClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    department<T extends departmentArgs = {}>(args?: Subset<T, departmentArgs>): CheckSelect<T, Prisma__departmentClient<department | null >, Prisma__departmentClient<departmentGetPayload<T> | null >>;

    DeletedServiceExpense<T extends DeletedServiceExpenseFindManyArgs = {}>(args?: Subset<T, DeletedServiceExpenseFindManyArgs>): CheckSelect<T, Promise<Array<DeletedServiceExpense>>, Promise<Array<DeletedServiceExpenseGetPayload<T>>>>;

    driving<T extends drivingFindManyArgs = {}>(args?: Subset<T, drivingFindManyArgs>): CheckSelect<T, Promise<Array<driving>>, Promise<Array<drivingGetPayload<T>>>>;

    serviceExpense<T extends serviceExpenseFindManyArgs = {}>(args?: Subset<T, serviceExpenseFindManyArgs>): CheckSelect<T, Promise<Array<serviceExpense>>, Promise<Array<serviceExpenseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * vehicle findUnique
   */
  export type vehicleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * Throw an Error if a vehicle can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which vehicle to fetch.
    **/
    where: vehicleWhereUniqueInput
  }


  /**
   * vehicle findFirst
   */
  export type vehicleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * Throw an Error if a vehicle can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which vehicle to fetch.
    **/
    where?: vehicleWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of vehicles to fetch.
    **/
    orderBy?: Enumerable<vehicleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
    **/
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of vehicles.
    **/
    distinct?: Enumerable<VehicleScalarFieldEnum>
  }


  /**
   * vehicle findMany
   */
  export type vehicleFindManyArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * Filter, which vehicles to fetch.
    **/
    where?: vehicleWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of vehicles to fetch.
    **/
    orderBy?: Enumerable<vehicleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
    **/
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
    **/
    skip?: number
    distinct?: Enumerable<VehicleScalarFieldEnum>
  }


  /**
   * vehicle create
   */
  export type vehicleCreateArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * The data needed to create a vehicle.
    **/
    data: XOR<vehicleUncheckedCreateInput, vehicleCreateInput>
  }


  /**
   * vehicle update
   */
  export type vehicleUpdateArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * The data needed to update a vehicle.
    **/
    data: XOR<vehicleUncheckedUpdateInput, vehicleUpdateInput>
    /**
     * Choose, which vehicle to update.
    **/
    where: vehicleWhereUniqueInput
  }


  /**
   * vehicle updateMany
   */
  export type vehicleUpdateManyArgs = {
    data: XOR<vehicleUncheckedUpdateManyInput, vehicleUpdateManyMutationInput>
    where?: vehicleWhereInput
  }


  /**
   * vehicle upsert
   */
  export type vehicleUpsertArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * The filter to search for the vehicle to update in case it exists.
    **/
    where: vehicleWhereUniqueInput
    /**
     * In case the vehicle found by the `where` argument doesn't exist, create a new vehicle with this data.
    **/
    create: XOR<vehicleUncheckedCreateInput, vehicleCreateInput>
    /**
     * In case the vehicle was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<vehicleUncheckedUpdateInput, vehicleUpdateInput>
  }


  /**
   * vehicle delete
   */
  export type vehicleDeleteArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
    /**
     * Filter which vehicle to delete.
    **/
    where: vehicleWhereUniqueInput
  }


  /**
   * vehicle deleteMany
   */
  export type vehicleDeleteManyArgs = {
    where?: vehicleWhereInput
  }


  /**
   * vehicle without action
   */
  export type vehicleArgs = {
    /**
     * Select specific fields to fetch from the vehicle
    **/
    select?: vehicleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: vehicleInclude | null
  }



  /**
   * Model drivers
   */


  export type AggregateDrivers = {
    count: DriversCountAggregateOutputType | null
    avg: DriversAvgAggregateOutputType | null
    sum: DriversSumAggregateOutputType | null
    min: DriversMinAggregateOutputType | null
    max: DriversMaxAggregateOutputType | null
  }

  export type DriversAvgAggregateOutputType = {
    driverId: number
    licensNo: number
  }

  export type DriversSumAggregateOutputType = {
    driverId: number
    licensNo: number
  }

  export type DriversMinAggregateOutputType = {
    driverId: number
    driverName: string | null
    phone: string | null
    licensNo: number
    description: string | null
    driverStatus: string | null
  }

  export type DriversMaxAggregateOutputType = {
    driverId: number
    driverName: string | null
    phone: string | null
    licensNo: number
    description: string | null
    driverStatus: string | null
  }

  export type DriversCountAggregateOutputType = {
    driverId: number
    driverName: number | null
    phone: number | null
    licensNo: number
    description: number | null
    driverStatus: number | null
    _all: number
  }


  export type DriversAvgAggregateInputType = {
    driverId?: true
    licensNo?: true
  }

  export type DriversSumAggregateInputType = {
    driverId?: true
    licensNo?: true
  }

  export type DriversMinAggregateInputType = {
    driverId?: true
    driverName?: true
    phone?: true
    licensNo?: true
    description?: true
    driverStatus?: true
  }

  export type DriversMaxAggregateInputType = {
    driverId?: true
    driverName?: true
    phone?: true
    licensNo?: true
    description?: true
    driverStatus?: true
  }

  export type DriversCountAggregateInputType = {
    driverId?: true
    driverName?: true
    phone?: true
    licensNo?: true
    description?: true
    driverStatus?: true
    _all?: true
  }

  export type DriversAggregateArgs = {
    /**
     * Filter which drivers to aggregate.
    **/
    where?: driversWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivers to fetch.
    **/
    orderBy?: Enumerable<driversOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivers
    **/
    count?: true | DriversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DriversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DriversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DriversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DriversMaxAggregateInputType
  }

  export type GetDriversAggregateType<T extends DriversAggregateArgs> = {
    [P in keyof T & keyof AggregateDrivers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrivers[P]>
      : GetScalarType<T[P], AggregateDrivers[P]>
  }



  export type driversSelect = {
    driverId?: boolean
    driverName?: boolean
    phone?: boolean
    licensNo?: boolean
    description?: boolean
    driverStatus?: boolean
    driving?: boolean | drivingFindManyArgs
  }

  export type driversInclude = {
    driving?: boolean | drivingFindManyArgs
  }

  export type driversGetPayload<
    S extends boolean | null | undefined | driversArgs,
    U = keyof S
      > = S extends true
        ? drivers
    : S extends undefined
    ? never
    : S extends driversArgs | driversFindManyArgs
    ?'include' extends U
    ? drivers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'driving'
        ? Array < drivingGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof drivers ?drivers [P]
  : 
          P extends 'driving'
        ? Array < drivingGetPayload<S['select'][P]>>  : never
  } 
    : drivers
  : drivers


  type driversCountArgs = Merge<
    Omit<driversFindManyArgs, 'select' | 'include'> & {
      select?: DriversCountAggregateInputType | true
    }
  >

  export interface driversDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Drivers that matches the filter.
     * @param {driversFindUniqueArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends driversFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, driversFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'drivers'> extends True ? CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>> : CheckSelect<T, Prisma__driversClient<drivers | null >, Prisma__driversClient<driversGetPayload<T> | null >>

    /**
     * Find the first Drivers that matches the filter.
     * @param {driversFindFirstArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends driversFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, driversFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'drivers'> extends True ? CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>> : CheckSelect<T, Prisma__driversClient<drivers | null >, Prisma__driversClient<driversGetPayload<T> | null >>

    /**
     * Find zero or more Drivers that matches the filter.
     * @param {driversFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.drivers.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.drivers.findMany({ take: 10 })
     * 
     * // Only select the `driverId`
     * const driversWithDriverIdOnly = await prisma.drivers.findMany({ select: { driverId: true } })
     * 
    **/
    findMany<T extends driversFindManyArgs>(
      args?: SelectSubset<T, driversFindManyArgs>
    ): CheckSelect<T, Promise<Array<drivers>>, Promise<Array<driversGetPayload<T>>>>

    /**
     * Create a Drivers.
     * @param {driversCreateArgs} args - Arguments to create a Drivers.
     * @example
     * // Create one Drivers
     * const Drivers = await prisma.drivers.create({
     *   data: {
     *     // ... data to create a Drivers
     *   }
     * })
     * 
    **/
    create<T extends driversCreateArgs>(
      args: SelectSubset<T, driversCreateArgs>
    ): CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>>

    /**
     * Delete a Drivers.
     * @param {driversDeleteArgs} args - Arguments to delete one Drivers.
     * @example
     * // Delete one Drivers
     * const Drivers = await prisma.drivers.delete({
     *   where: {
     *     // ... filter to delete one Drivers
     *   }
     * })
     * 
    **/
    delete<T extends driversDeleteArgs>(
      args: SelectSubset<T, driversDeleteArgs>
    ): CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>>

    /**
     * Update one Drivers.
     * @param {driversUpdateArgs} args - Arguments to update one Drivers.
     * @example
     * // Update one Drivers
     * const drivers = await prisma.drivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends driversUpdateArgs>(
      args: SelectSubset<T, driversUpdateArgs>
    ): CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>>

    /**
     * Delete zero or more Drivers.
     * @param {driversDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.drivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends driversDeleteManyArgs>(
      args?: SelectSubset<T, driversDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * @param {driversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const drivers = await prisma.drivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends driversUpdateManyArgs>(
      args: SelectSubset<T, driversUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Drivers.
     * @param {driversUpsertArgs} args - Arguments to update or create a Drivers.
     * @example
     * // Update or create a Drivers
     * const drivers = await prisma.drivers.upsert({
     *   create: {
     *     // ... data to create a Drivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drivers we want to update
     *   }
     * })
    **/
    upsert<T extends driversUpsertArgs>(
      args: SelectSubset<T, driversUpsertArgs>
    ): CheckSelect<T, Prisma__driversClient<drivers>, Prisma__driversClient<driversGetPayload<T>>>

    /**
     * Count the number of Drivers.
     * @param {driversCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.drivers.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends driversCountArgs>(
      args?: Subset<T, driversCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drivers.
     * @param {DriversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriversAggregateArgs>(args: Subset<T, DriversAggregateArgs>): Promise<GetDriversAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for drivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__driversClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    driving<T extends drivingFindManyArgs = {}>(args?: Subset<T, drivingFindManyArgs>): CheckSelect<T, Promise<Array<driving>>, Promise<Array<drivingGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * drivers findUnique
   */
  export type driversFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * Throw an Error if a drivers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which drivers to fetch.
    **/
    where: driversWhereUniqueInput
  }


  /**
   * drivers findFirst
   */
  export type driversFindFirstArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * Throw an Error if a drivers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which drivers to fetch.
    **/
    where?: driversWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivers to fetch.
    **/
    orderBy?: Enumerable<driversOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
    **/
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of drivers.
    **/
    distinct?: Enumerable<DriversScalarFieldEnum>
  }


  /**
   * drivers findMany
   */
  export type driversFindManyArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
    **/
    where?: driversWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivers to fetch.
    **/
    orderBy?: Enumerable<driversOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivers.
    **/
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
    **/
    skip?: number
    distinct?: Enumerable<DriversScalarFieldEnum>
  }


  /**
   * drivers create
   */
  export type driversCreateArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * The data needed to create a drivers.
    **/
    data: XOR<driversUncheckedCreateInput, driversCreateInput>
  }


  /**
   * drivers update
   */
  export type driversUpdateArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * The data needed to update a drivers.
    **/
    data: XOR<driversUncheckedUpdateInput, driversUpdateInput>
    /**
     * Choose, which drivers to update.
    **/
    where: driversWhereUniqueInput
  }


  /**
   * drivers updateMany
   */
  export type driversUpdateManyArgs = {
    data: XOR<driversUncheckedUpdateManyInput, driversUpdateManyMutationInput>
    where?: driversWhereInput
  }


  /**
   * drivers upsert
   */
  export type driversUpsertArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * The filter to search for the drivers to update in case it exists.
    **/
    where: driversWhereUniqueInput
    /**
     * In case the drivers found by the `where` argument doesn't exist, create a new drivers with this data.
    **/
    create: XOR<driversUncheckedCreateInput, driversCreateInput>
    /**
     * In case the drivers was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<driversUncheckedUpdateInput, driversUpdateInput>
  }


  /**
   * drivers delete
   */
  export type driversDeleteArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
    /**
     * Filter which drivers to delete.
    **/
    where: driversWhereUniqueInput
  }


  /**
   * drivers deleteMany
   */
  export type driversDeleteManyArgs = {
    where?: driversWhereInput
  }


  /**
   * drivers without action
   */
  export type driversArgs = {
    /**
     * Select specific fields to fetch from the drivers
    **/
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: driversInclude | null
  }



  /**
   * Model DeletedItemPart
   */


  export type AggregateDeletedItemPart = {
    count: DeletedItemPartCountAggregateOutputType | null
    avg: DeletedItemPartAvgAggregateOutputType | null
    sum: DeletedItemPartSumAggregateOutputType | null
    min: DeletedItemPartMinAggregateOutputType | null
    max: DeletedItemPartMaxAggregateOutputType | null
  }

  export type DeletedItemPartAvgAggregateOutputType = {
    partQuantity: number
    partPrice: number
    id: number
    supplierId: number | null
    garageId: number | null
  }

  export type DeletedItemPartSumAggregateOutputType = {
    partQuantity: number
    partPrice: number
    id: number
    supplierId: number | null
    garageId: number | null
  }

  export type DeletedItemPartMinAggregateOutputType = {
    itemPart: string | null
    partName: string | null
    partQuantity: number
    partPrice: number
    createdAt: Date | null
    updatedAt: Date | null
    id: number
    supplierId: number | null
    garageId: number | null
  }

  export type DeletedItemPartMaxAggregateOutputType = {
    itemPart: string | null
    partName: string | null
    partQuantity: number
    partPrice: number
    createdAt: Date | null
    updatedAt: Date | null
    id: number
    supplierId: number | null
    garageId: number | null
  }

  export type DeletedItemPartCountAggregateOutputType = {
    itemPart: number | null
    partName: number | null
    partQuantity: number
    partPrice: number
    createdAt: number | null
    updatedAt: number | null
    id: number
    supplierId: number | null
    garageId: number | null
    _all: number
  }


  export type DeletedItemPartAvgAggregateInputType = {
    partQuantity?: true
    partPrice?: true
    id?: true
    supplierId?: true
    garageId?: true
  }

  export type DeletedItemPartSumAggregateInputType = {
    partQuantity?: true
    partPrice?: true
    id?: true
    supplierId?: true
    garageId?: true
  }

  export type DeletedItemPartMinAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
    garageId?: true
  }

  export type DeletedItemPartMaxAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
    garageId?: true
  }

  export type DeletedItemPartCountAggregateInputType = {
    itemPart?: true
    partName?: true
    partQuantity?: true
    partPrice?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    supplierId?: true
    garageId?: true
    _all?: true
  }

  export type DeletedItemPartAggregateArgs = {
    /**
     * Filter which DeletedItemPart to aggregate.
    **/
    where?: DeletedItemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedItemParts to fetch.
    **/
    orderBy?: Enumerable<DeletedItemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: DeletedItemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedItemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedItemParts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedItemParts
    **/
    count?: true | DeletedItemPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DeletedItemPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DeletedItemPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DeletedItemPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DeletedItemPartMaxAggregateInputType
  }

  export type GetDeletedItemPartAggregateType<T extends DeletedItemPartAggregateArgs> = {
    [P in keyof T & keyof AggregateDeletedItemPart]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedItemPart[P]>
      : GetScalarType<T[P], AggregateDeletedItemPart[P]>
  }



  export type DeletedItemPartSelect = {
    itemPart?: boolean
    partName?: boolean
    partQuantity?: boolean
    partPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    supplierId?: boolean
    garageId?: boolean
    garage?: boolean | garageArgs
    supplier?: boolean | supplierArgs
  }

  export type DeletedItemPartInclude = {
    garage?: boolean | garageArgs
    supplier?: boolean | supplierArgs
  }

  export type DeletedItemPartGetPayload<
    S extends boolean | null | undefined | DeletedItemPartArgs,
    U = keyof S
      > = S extends true
        ? DeletedItemPart
    : S extends undefined
    ? never
    : S extends DeletedItemPartArgs | DeletedItemPartFindManyArgs
    ?'include' extends U
    ? DeletedItemPart  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'garage'
        ? garageGetPayload<S['include'][P]> | null :
        P extends 'supplier'
        ? supplierGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DeletedItemPart ?DeletedItemPart [P]
  : 
          P extends 'garage'
        ? garageGetPayload<S['select'][P]> | null :
        P extends 'supplier'
        ? supplierGetPayload<S['select'][P]> | null : never
  } 
    : DeletedItemPart
  : DeletedItemPart


  type DeletedItemPartCountArgs = Merge<
    Omit<DeletedItemPartFindManyArgs, 'select' | 'include'> & {
      select?: DeletedItemPartCountAggregateInputType | true
    }
  >

  export interface DeletedItemPartDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DeletedItemPart that matches the filter.
     * @param {DeletedItemPartFindUniqueArgs} args - Arguments to find a DeletedItemPart
     * @example
     * // Get one DeletedItemPart
     * const deletedItemPart = await prisma.deletedItemPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeletedItemPartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeletedItemPartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeletedItemPart'> extends True ? CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>> : CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart | null >, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T> | null >>

    /**
     * Find the first DeletedItemPart that matches the filter.
     * @param {DeletedItemPartFindFirstArgs} args - Arguments to find a DeletedItemPart
     * @example
     * // Get one DeletedItemPart
     * const deletedItemPart = await prisma.deletedItemPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeletedItemPartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeletedItemPartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeletedItemPart'> extends True ? CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>> : CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart | null >, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T> | null >>

    /**
     * Find zero or more DeletedItemParts that matches the filter.
     * @param {DeletedItemPartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedItemParts
     * const deletedItemParts = await prisma.deletedItemPart.findMany()
     * 
     * // Get first 10 DeletedItemParts
     * const deletedItemParts = await prisma.deletedItemPart.findMany({ take: 10 })
     * 
     * // Only select the `itemPart`
     * const deletedItemPartWithItemPartOnly = await prisma.deletedItemPart.findMany({ select: { itemPart: true } })
     * 
    **/
    findMany<T extends DeletedItemPartFindManyArgs>(
      args?: SelectSubset<T, DeletedItemPartFindManyArgs>
    ): CheckSelect<T, Promise<Array<DeletedItemPart>>, Promise<Array<DeletedItemPartGetPayload<T>>>>

    /**
     * Create a DeletedItemPart.
     * @param {DeletedItemPartCreateArgs} args - Arguments to create a DeletedItemPart.
     * @example
     * // Create one DeletedItemPart
     * const DeletedItemPart = await prisma.deletedItemPart.create({
     *   data: {
     *     // ... data to create a DeletedItemPart
     *   }
     * })
     * 
    **/
    create<T extends DeletedItemPartCreateArgs>(
      args: SelectSubset<T, DeletedItemPartCreateArgs>
    ): CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>>

    /**
     * Delete a DeletedItemPart.
     * @param {DeletedItemPartDeleteArgs} args - Arguments to delete one DeletedItemPart.
     * @example
     * // Delete one DeletedItemPart
     * const DeletedItemPart = await prisma.deletedItemPart.delete({
     *   where: {
     *     // ... filter to delete one DeletedItemPart
     *   }
     * })
     * 
    **/
    delete<T extends DeletedItemPartDeleteArgs>(
      args: SelectSubset<T, DeletedItemPartDeleteArgs>
    ): CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>>

    /**
     * Update one DeletedItemPart.
     * @param {DeletedItemPartUpdateArgs} args - Arguments to update one DeletedItemPart.
     * @example
     * // Update one DeletedItemPart
     * const deletedItemPart = await prisma.deletedItemPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeletedItemPartUpdateArgs>(
      args: SelectSubset<T, DeletedItemPartUpdateArgs>
    ): CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>>

    /**
     * Delete zero or more DeletedItemParts.
     * @param {DeletedItemPartDeleteManyArgs} args - Arguments to filter DeletedItemParts to delete.
     * @example
     * // Delete a few DeletedItemParts
     * const { count } = await prisma.deletedItemPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeletedItemPartDeleteManyArgs>(
      args?: SelectSubset<T, DeletedItemPartDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more DeletedItemParts.
     * @param {DeletedItemPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedItemParts
     * const deletedItemPart = await prisma.deletedItemPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeletedItemPartUpdateManyArgs>(
      args: SelectSubset<T, DeletedItemPartUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one DeletedItemPart.
     * @param {DeletedItemPartUpsertArgs} args - Arguments to update or create a DeletedItemPart.
     * @example
     * // Update or create a DeletedItemPart
     * const deletedItemPart = await prisma.deletedItemPart.upsert({
     *   create: {
     *     // ... data to create a DeletedItemPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedItemPart we want to update
     *   }
     * })
    **/
    upsert<T extends DeletedItemPartUpsertArgs>(
      args: SelectSubset<T, DeletedItemPartUpsertArgs>
    ): CheckSelect<T, Prisma__DeletedItemPartClient<DeletedItemPart>, Prisma__DeletedItemPartClient<DeletedItemPartGetPayload<T>>>

    /**
     * Count the number of DeletedItemParts.
     * @param {DeletedItemPartCountArgs} args - Arguments to filter DeletedItemParts to count.
     * @example
     * // Count the number of DeletedItemParts
     * const count = await prisma.deletedItemPart.count({
     *   where: {
     *     // ... the filter for the DeletedItemParts we want to count
     *   }
     * })
    **/
    count<T extends DeletedItemPartCountArgs>(
      args?: Subset<T, DeletedItemPartCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedItemPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedItemPart.
     * @param {DeletedItemPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedItemPartAggregateArgs>(args: Subset<T, DeletedItemPartAggregateArgs>): Promise<GetDeletedItemPartAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedItemPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeletedItemPartClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    garage<T extends garageArgs = {}>(args?: Subset<T, garageArgs>): CheckSelect<T, Prisma__garageClient<garage | null >, Prisma__garageClient<garageGetPayload<T> | null >>;

    supplier<T extends supplierArgs = {}>(args?: Subset<T, supplierArgs>): CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DeletedItemPart findUnique
   */
  export type DeletedItemPartFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * Throw an Error if a DeletedItemPart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DeletedItemPart to fetch.
    **/
    where: DeletedItemPartWhereUniqueInput
  }


  /**
   * DeletedItemPart findFirst
   */
  export type DeletedItemPartFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * Throw an Error if a DeletedItemPart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DeletedItemPart to fetch.
    **/
    where?: DeletedItemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedItemParts to fetch.
    **/
    orderBy?: Enumerable<DeletedItemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedItemParts.
    **/
    cursor?: DeletedItemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedItemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedItemParts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of DeletedItemParts.
    **/
    distinct?: Enumerable<DeletedItemPartScalarFieldEnum>
  }


  /**
   * DeletedItemPart findMany
   */
  export type DeletedItemPartFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * Filter, which DeletedItemParts to fetch.
    **/
    where?: DeletedItemPartWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedItemParts to fetch.
    **/
    orderBy?: Enumerable<DeletedItemPartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedItemParts.
    **/
    cursor?: DeletedItemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedItemParts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedItemParts.
    **/
    skip?: number
    distinct?: Enumerable<DeletedItemPartScalarFieldEnum>
  }


  /**
   * DeletedItemPart create
   */
  export type DeletedItemPartCreateArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * The data needed to create a DeletedItemPart.
    **/
    data: XOR<DeletedItemPartUncheckedCreateInput, DeletedItemPartCreateInput>
  }


  /**
   * DeletedItemPart update
   */
  export type DeletedItemPartUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * The data needed to update a DeletedItemPart.
    **/
    data: XOR<DeletedItemPartUncheckedUpdateInput, DeletedItemPartUpdateInput>
    /**
     * Choose, which DeletedItemPart to update.
    **/
    where: DeletedItemPartWhereUniqueInput
  }


  /**
   * DeletedItemPart updateMany
   */
  export type DeletedItemPartUpdateManyArgs = {
    data: XOR<DeletedItemPartUncheckedUpdateManyInput, DeletedItemPartUpdateManyMutationInput>
    where?: DeletedItemPartWhereInput
  }


  /**
   * DeletedItemPart upsert
   */
  export type DeletedItemPartUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * The filter to search for the DeletedItemPart to update in case it exists.
    **/
    where: DeletedItemPartWhereUniqueInput
    /**
     * In case the DeletedItemPart found by the `where` argument doesn't exist, create a new DeletedItemPart with this data.
    **/
    create: XOR<DeletedItemPartUncheckedCreateInput, DeletedItemPartCreateInput>
    /**
     * In case the DeletedItemPart was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<DeletedItemPartUncheckedUpdateInput, DeletedItemPartUpdateInput>
  }


  /**
   * DeletedItemPart delete
   */
  export type DeletedItemPartDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
    /**
     * Filter which DeletedItemPart to delete.
    **/
    where: DeletedItemPartWhereUniqueInput
  }


  /**
   * DeletedItemPart deleteMany
   */
  export type DeletedItemPartDeleteManyArgs = {
    where?: DeletedItemPartWhereInput
  }


  /**
   * DeletedItemPart without action
   */
  export type DeletedItemPartArgs = {
    /**
     * Select specific fields to fetch from the DeletedItemPart
    **/
    select?: DeletedItemPartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedItemPartInclude | null
  }



  /**
   * Model driving
   */


  export type AggregateDriving = {
    count: DrivingCountAggregateOutputType | null
    avg: DrivingAvgAggregateOutputType | null
    sum: DrivingSumAggregateOutputType | null
    min: DrivingMinAggregateOutputType | null
    max: DrivingMaxAggregateOutputType | null
  }

  export type DrivingAvgAggregateOutputType = {
    drivingId: number
    vehicleId: number | null
    driverId: number | null
  }

  export type DrivingSumAggregateOutputType = {
    drivingId: number
    vehicleId: number | null
    driverId: number | null
  }

  export type DrivingMinAggregateOutputType = {
    drivingId: number
    drivingDate: Date | null
    drivingDescription: string | null
    drivingStatus: string | null
    vehicleId: number | null
    driverId: number | null
    reason: string | null
  }

  export type DrivingMaxAggregateOutputType = {
    drivingId: number
    drivingDate: Date | null
    drivingDescription: string | null
    drivingStatus: string | null
    vehicleId: number | null
    driverId: number | null
    reason: string | null
  }

  export type DrivingCountAggregateOutputType = {
    drivingId: number
    drivingDate: number | null
    drivingDescription: number | null
    drivingStatus: number | null
    vehicleId: number | null
    driverId: number | null
    reason: number | null
    _all: number
  }


  export type DrivingAvgAggregateInputType = {
    drivingId?: true
    vehicleId?: true
    driverId?: true
  }

  export type DrivingSumAggregateInputType = {
    drivingId?: true
    vehicleId?: true
    driverId?: true
  }

  export type DrivingMinAggregateInputType = {
    drivingId?: true
    drivingDate?: true
    drivingDescription?: true
    drivingStatus?: true
    vehicleId?: true
    driverId?: true
    reason?: true
  }

  export type DrivingMaxAggregateInputType = {
    drivingId?: true
    drivingDate?: true
    drivingDescription?: true
    drivingStatus?: true
    vehicleId?: true
    driverId?: true
    reason?: true
  }

  export type DrivingCountAggregateInputType = {
    drivingId?: true
    drivingDate?: true
    drivingDescription?: true
    drivingStatus?: true
    vehicleId?: true
    driverId?: true
    reason?: true
    _all?: true
  }

  export type DrivingAggregateArgs = {
    /**
     * Filter which driving to aggregate.
    **/
    where?: drivingWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivings to fetch.
    **/
    orderBy?: Enumerable<drivingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: drivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivings
    **/
    count?: true | DrivingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DrivingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DrivingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DrivingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DrivingMaxAggregateInputType
  }

  export type GetDrivingAggregateType<T extends DrivingAggregateArgs> = {
    [P in keyof T & keyof AggregateDriving]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriving[P]>
      : GetScalarType<T[P], AggregateDriving[P]>
  }



  export type drivingSelect = {
    drivingId?: boolean
    drivingDate?: boolean
    drivingDescription?: boolean
    drivingStatus?: boolean
    vehicleId?: boolean
    driverId?: boolean
    reason?: boolean
    drivers?: boolean | driversArgs
    vehicle?: boolean | vehicleArgs
  }

  export type drivingInclude = {
    drivers?: boolean | driversArgs
    vehicle?: boolean | vehicleArgs
  }

  export type drivingGetPayload<
    S extends boolean | null | undefined | drivingArgs,
    U = keyof S
      > = S extends true
        ? driving
    : S extends undefined
    ? never
    : S extends drivingArgs | drivingFindManyArgs
    ?'include' extends U
    ? driving  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'drivers'
        ? driversGetPayload<S['include'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof driving ?driving [P]
  : 
          P extends 'drivers'
        ? driversGetPayload<S['select'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['select'][P]> | null : never
  } 
    : driving
  : driving


  type drivingCountArgs = Merge<
    Omit<drivingFindManyArgs, 'select' | 'include'> & {
      select?: DrivingCountAggregateInputType | true
    }
  >

  export interface drivingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Driving that matches the filter.
     * @param {drivingFindUniqueArgs} args - Arguments to find a Driving
     * @example
     * // Get one Driving
     * const driving = await prisma.driving.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends drivingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, drivingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'driving'> extends True ? CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>> : CheckSelect<T, Prisma__drivingClient<driving | null >, Prisma__drivingClient<drivingGetPayload<T> | null >>

    /**
     * Find the first Driving that matches the filter.
     * @param {drivingFindFirstArgs} args - Arguments to find a Driving
     * @example
     * // Get one Driving
     * const driving = await prisma.driving.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends drivingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, drivingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'driving'> extends True ? CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>> : CheckSelect<T, Prisma__drivingClient<driving | null >, Prisma__drivingClient<drivingGetPayload<T> | null >>

    /**
     * Find zero or more Drivings that matches the filter.
     * @param {drivingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivings
     * const drivings = await prisma.driving.findMany()
     * 
     * // Get first 10 Drivings
     * const drivings = await prisma.driving.findMany({ take: 10 })
     * 
     * // Only select the `drivingId`
     * const drivingWithDrivingIdOnly = await prisma.driving.findMany({ select: { drivingId: true } })
     * 
    **/
    findMany<T extends drivingFindManyArgs>(
      args?: SelectSubset<T, drivingFindManyArgs>
    ): CheckSelect<T, Promise<Array<driving>>, Promise<Array<drivingGetPayload<T>>>>

    /**
     * Create a Driving.
     * @param {drivingCreateArgs} args - Arguments to create a Driving.
     * @example
     * // Create one Driving
     * const Driving = await prisma.driving.create({
     *   data: {
     *     // ... data to create a Driving
     *   }
     * })
     * 
    **/
    create<T extends drivingCreateArgs>(
      args: SelectSubset<T, drivingCreateArgs>
    ): CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>>

    /**
     * Delete a Driving.
     * @param {drivingDeleteArgs} args - Arguments to delete one Driving.
     * @example
     * // Delete one Driving
     * const Driving = await prisma.driving.delete({
     *   where: {
     *     // ... filter to delete one Driving
     *   }
     * })
     * 
    **/
    delete<T extends drivingDeleteArgs>(
      args: SelectSubset<T, drivingDeleteArgs>
    ): CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>>

    /**
     * Update one Driving.
     * @param {drivingUpdateArgs} args - Arguments to update one Driving.
     * @example
     * // Update one Driving
     * const driving = await prisma.driving.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends drivingUpdateArgs>(
      args: SelectSubset<T, drivingUpdateArgs>
    ): CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>>

    /**
     * Delete zero or more Drivings.
     * @param {drivingDeleteManyArgs} args - Arguments to filter Drivings to delete.
     * @example
     * // Delete a few Drivings
     * const { count } = await prisma.driving.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends drivingDeleteManyArgs>(
      args?: SelectSubset<T, drivingDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Drivings.
     * @param {drivingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivings
     * const driving = await prisma.driving.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends drivingUpdateManyArgs>(
      args: SelectSubset<T, drivingUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Driving.
     * @param {drivingUpsertArgs} args - Arguments to update or create a Driving.
     * @example
     * // Update or create a Driving
     * const driving = await prisma.driving.upsert({
     *   create: {
     *     // ... data to create a Driving
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driving we want to update
     *   }
     * })
    **/
    upsert<T extends drivingUpsertArgs>(
      args: SelectSubset<T, drivingUpsertArgs>
    ): CheckSelect<T, Prisma__drivingClient<driving>, Prisma__drivingClient<drivingGetPayload<T>>>

    /**
     * Count the number of Drivings.
     * @param {drivingCountArgs} args - Arguments to filter Drivings to count.
     * @example
     * // Count the number of Drivings
     * const count = await prisma.driving.count({
     *   where: {
     *     // ... the filter for the Drivings we want to count
     *   }
     * })
    **/
    count<T extends drivingCountArgs>(
      args?: Subset<T, drivingCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrivingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driving.
     * @param {DrivingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrivingAggregateArgs>(args: Subset<T, DrivingAggregateArgs>): Promise<GetDrivingAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for driving.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__drivingClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    drivers<T extends driversArgs = {}>(args?: Subset<T, driversArgs>): CheckSelect<T, Prisma__driversClient<drivers | null >, Prisma__driversClient<driversGetPayload<T> | null >>;

    vehicle<T extends vehicleArgs = {}>(args?: Subset<T, vehicleArgs>): CheckSelect<T, Prisma__vehicleClient<vehicle | null >, Prisma__vehicleClient<vehicleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * driving findUnique
   */
  export type drivingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * Throw an Error if a driving can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which driving to fetch.
    **/
    where: drivingWhereUniqueInput
  }


  /**
   * driving findFirst
   */
  export type drivingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * Throw an Error if a driving can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which driving to fetch.
    **/
    where?: drivingWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivings to fetch.
    **/
    orderBy?: Enumerable<drivingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivings.
    **/
    cursor?: drivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivings.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of drivings.
    **/
    distinct?: Enumerable<DrivingScalarFieldEnum>
  }


  /**
   * driving findMany
   */
  export type drivingFindManyArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * Filter, which drivings to fetch.
    **/
    where?: drivingWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of drivings to fetch.
    **/
    orderBy?: Enumerable<drivingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivings.
    **/
    cursor?: drivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivings.
    **/
    skip?: number
    distinct?: Enumerable<DrivingScalarFieldEnum>
  }


  /**
   * driving create
   */
  export type drivingCreateArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * The data needed to create a driving.
    **/
    data: XOR<drivingUncheckedCreateInput, drivingCreateInput>
  }


  /**
   * driving update
   */
  export type drivingUpdateArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * The data needed to update a driving.
    **/
    data: XOR<drivingUncheckedUpdateInput, drivingUpdateInput>
    /**
     * Choose, which driving to update.
    **/
    where: drivingWhereUniqueInput
  }


  /**
   * driving updateMany
   */
  export type drivingUpdateManyArgs = {
    data: XOR<drivingUncheckedUpdateManyInput, drivingUpdateManyMutationInput>
    where?: drivingWhereInput
  }


  /**
   * driving upsert
   */
  export type drivingUpsertArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * The filter to search for the driving to update in case it exists.
    **/
    where: drivingWhereUniqueInput
    /**
     * In case the driving found by the `where` argument doesn't exist, create a new driving with this data.
    **/
    create: XOR<drivingUncheckedCreateInput, drivingCreateInput>
    /**
     * In case the driving was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<drivingUncheckedUpdateInput, drivingUpdateInput>
  }


  /**
   * driving delete
   */
  export type drivingDeleteArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
    /**
     * Filter which driving to delete.
    **/
    where: drivingWhereUniqueInput
  }


  /**
   * driving deleteMany
   */
  export type drivingDeleteManyArgs = {
    where?: drivingWhereInput
  }


  /**
   * driving without action
   */
  export type drivingArgs = {
    /**
     * Select specific fields to fetch from the driving
    **/
    select?: drivingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: drivingInclude | null
  }



  /**
   * Model DeletedServiceExpense
   */


  export type AggregateDeletedServiceExpense = {
    count: DeletedServiceExpenseCountAggregateOutputType | null
    avg: DeletedServiceExpenseAvgAggregateOutputType | null
    sum: DeletedServiceExpenseSumAggregateOutputType | null
    min: DeletedServiceExpenseMinAggregateOutputType | null
    max: DeletedServiceExpenseMaxAggregateOutputType | null
  }

  export type DeletedServiceExpenseAvgAggregateOutputType = {
    id: number
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    vehicleId: number | null
    garageId: number | null
  }

  export type DeletedServiceExpenseSumAggregateOutputType = {
    id: number
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    vehicleId: number | null
    garageId: number | null
  }

  export type DeletedServiceExpenseMinAggregateOutputType = {
    id: number
    invoiceNumber: string | null
    serviceDescription: string | null
    serviceDate: Date | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleId: number | null
    garageId: number | null
  }

  export type DeletedServiceExpenseMaxAggregateOutputType = {
    id: number
    invoiceNumber: string | null
    serviceDescription: string | null
    serviceDate: Date | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleId: number | null
    garageId: number | null
  }

  export type DeletedServiceExpenseCountAggregateOutputType = {
    id: number
    invoiceNumber: number | null
    serviceDescription: number | null
    serviceDate: number | null
    serviceCost: number | null
    totalCost: number | null
    purchaseID: number | null
    createdAt: number | null
    updatedAt: number | null
    vehicleId: number | null
    garageId: number | null
    _all: number
  }


  export type DeletedServiceExpenseAvgAggregateInputType = {
    id?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    vehicleId?: true
    garageId?: true
  }

  export type DeletedServiceExpenseSumAggregateInputType = {
    id?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    vehicleId?: true
    garageId?: true
  }

  export type DeletedServiceExpenseMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
  }

  export type DeletedServiceExpenseMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
  }

  export type DeletedServiceExpenseCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    serviceDescription?: true
    serviceDate?: true
    serviceCost?: true
    totalCost?: true
    purchaseID?: true
    createdAt?: true
    updatedAt?: true
    vehicleId?: true
    garageId?: true
    _all?: true
  }

  export type DeletedServiceExpenseAggregateArgs = {
    /**
     * Filter which DeletedServiceExpense to aggregate.
    **/
    where?: DeletedServiceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedServiceExpenses to fetch.
    **/
    orderBy?: Enumerable<DeletedServiceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: DeletedServiceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedServiceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedServiceExpenses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedServiceExpenses
    **/
    count?: true | DeletedServiceExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DeletedServiceExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DeletedServiceExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DeletedServiceExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DeletedServiceExpenseMaxAggregateInputType
  }

  export type GetDeletedServiceExpenseAggregateType<T extends DeletedServiceExpenseAggregateArgs> = {
    [P in keyof T & keyof AggregateDeletedServiceExpense]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedServiceExpense[P]>
      : GetScalarType<T[P], AggregateDeletedServiceExpense[P]>
  }



  export type DeletedServiceExpenseSelect = {
    id?: boolean
    invoiceNumber?: boolean
    serviceDescription?: boolean
    serviceDate?: boolean
    serviceCost?: boolean
    totalCost?: boolean
    purchaseID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleId?: boolean
    garageId?: boolean
    garage?: boolean | garageArgs
    vehicle?: boolean | vehicleArgs
  }

  export type DeletedServiceExpenseInclude = {
    garage?: boolean | garageArgs
    vehicle?: boolean | vehicleArgs
  }

  export type DeletedServiceExpenseGetPayload<
    S extends boolean | null | undefined | DeletedServiceExpenseArgs,
    U = keyof S
      > = S extends true
        ? DeletedServiceExpense
    : S extends undefined
    ? never
    : S extends DeletedServiceExpenseArgs | DeletedServiceExpenseFindManyArgs
    ?'include' extends U
    ? DeletedServiceExpense  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'garage'
        ? garageGetPayload<S['include'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DeletedServiceExpense ?DeletedServiceExpense [P]
  : 
          P extends 'garage'
        ? garageGetPayload<S['select'][P]> | null :
        P extends 'vehicle'
        ? vehicleGetPayload<S['select'][P]> | null : never
  } 
    : DeletedServiceExpense
  : DeletedServiceExpense


  type DeletedServiceExpenseCountArgs = Merge<
    Omit<DeletedServiceExpenseFindManyArgs, 'select' | 'include'> & {
      select?: DeletedServiceExpenseCountAggregateInputType | true
    }
  >

  export interface DeletedServiceExpenseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DeletedServiceExpense that matches the filter.
     * @param {DeletedServiceExpenseFindUniqueArgs} args - Arguments to find a DeletedServiceExpense
     * @example
     * // Get one DeletedServiceExpense
     * const deletedServiceExpense = await prisma.deletedServiceExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeletedServiceExpenseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeletedServiceExpenseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeletedServiceExpense'> extends True ? CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>> : CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense | null >, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T> | null >>

    /**
     * Find the first DeletedServiceExpense that matches the filter.
     * @param {DeletedServiceExpenseFindFirstArgs} args - Arguments to find a DeletedServiceExpense
     * @example
     * // Get one DeletedServiceExpense
     * const deletedServiceExpense = await prisma.deletedServiceExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeletedServiceExpenseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeletedServiceExpenseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeletedServiceExpense'> extends True ? CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>> : CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense | null >, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T> | null >>

    /**
     * Find zero or more DeletedServiceExpenses that matches the filter.
     * @param {DeletedServiceExpenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedServiceExpenses
     * const deletedServiceExpenses = await prisma.deletedServiceExpense.findMany()
     * 
     * // Get first 10 DeletedServiceExpenses
     * const deletedServiceExpenses = await prisma.deletedServiceExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletedServiceExpenseWithIdOnly = await prisma.deletedServiceExpense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeletedServiceExpenseFindManyArgs>(
      args?: SelectSubset<T, DeletedServiceExpenseFindManyArgs>
    ): CheckSelect<T, Promise<Array<DeletedServiceExpense>>, Promise<Array<DeletedServiceExpenseGetPayload<T>>>>

    /**
     * Create a DeletedServiceExpense.
     * @param {DeletedServiceExpenseCreateArgs} args - Arguments to create a DeletedServiceExpense.
     * @example
     * // Create one DeletedServiceExpense
     * const DeletedServiceExpense = await prisma.deletedServiceExpense.create({
     *   data: {
     *     // ... data to create a DeletedServiceExpense
     *   }
     * })
     * 
    **/
    create<T extends DeletedServiceExpenseCreateArgs>(
      args: SelectSubset<T, DeletedServiceExpenseCreateArgs>
    ): CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>>

    /**
     * Delete a DeletedServiceExpense.
     * @param {DeletedServiceExpenseDeleteArgs} args - Arguments to delete one DeletedServiceExpense.
     * @example
     * // Delete one DeletedServiceExpense
     * const DeletedServiceExpense = await prisma.deletedServiceExpense.delete({
     *   where: {
     *     // ... filter to delete one DeletedServiceExpense
     *   }
     * })
     * 
    **/
    delete<T extends DeletedServiceExpenseDeleteArgs>(
      args: SelectSubset<T, DeletedServiceExpenseDeleteArgs>
    ): CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>>

    /**
     * Update one DeletedServiceExpense.
     * @param {DeletedServiceExpenseUpdateArgs} args - Arguments to update one DeletedServiceExpense.
     * @example
     * // Update one DeletedServiceExpense
     * const deletedServiceExpense = await prisma.deletedServiceExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeletedServiceExpenseUpdateArgs>(
      args: SelectSubset<T, DeletedServiceExpenseUpdateArgs>
    ): CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>>

    /**
     * Delete zero or more DeletedServiceExpenses.
     * @param {DeletedServiceExpenseDeleteManyArgs} args - Arguments to filter DeletedServiceExpenses to delete.
     * @example
     * // Delete a few DeletedServiceExpenses
     * const { count } = await prisma.deletedServiceExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeletedServiceExpenseDeleteManyArgs>(
      args?: SelectSubset<T, DeletedServiceExpenseDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more DeletedServiceExpenses.
     * @param {DeletedServiceExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedServiceExpenses
     * const deletedServiceExpense = await prisma.deletedServiceExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeletedServiceExpenseUpdateManyArgs>(
      args: SelectSubset<T, DeletedServiceExpenseUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one DeletedServiceExpense.
     * @param {DeletedServiceExpenseUpsertArgs} args - Arguments to update or create a DeletedServiceExpense.
     * @example
     * // Update or create a DeletedServiceExpense
     * const deletedServiceExpense = await prisma.deletedServiceExpense.upsert({
     *   create: {
     *     // ... data to create a DeletedServiceExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedServiceExpense we want to update
     *   }
     * })
    **/
    upsert<T extends DeletedServiceExpenseUpsertArgs>(
      args: SelectSubset<T, DeletedServiceExpenseUpsertArgs>
    ): CheckSelect<T, Prisma__DeletedServiceExpenseClient<DeletedServiceExpense>, Prisma__DeletedServiceExpenseClient<DeletedServiceExpenseGetPayload<T>>>

    /**
     * Count the number of DeletedServiceExpenses.
     * @param {DeletedServiceExpenseCountArgs} args - Arguments to filter DeletedServiceExpenses to count.
     * @example
     * // Count the number of DeletedServiceExpenses
     * const count = await prisma.deletedServiceExpense.count({
     *   where: {
     *     // ... the filter for the DeletedServiceExpenses we want to count
     *   }
     * })
    **/
    count<T extends DeletedServiceExpenseCountArgs>(
      args?: Subset<T, DeletedServiceExpenseCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedServiceExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedServiceExpense.
     * @param {DeletedServiceExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedServiceExpenseAggregateArgs>(args: Subset<T, DeletedServiceExpenseAggregateArgs>): Promise<GetDeletedServiceExpenseAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedServiceExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeletedServiceExpenseClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    garage<T extends garageArgs = {}>(args?: Subset<T, garageArgs>): CheckSelect<T, Prisma__garageClient<garage | null >, Prisma__garageClient<garageGetPayload<T> | null >>;

    vehicle<T extends vehicleArgs = {}>(args?: Subset<T, vehicleArgs>): CheckSelect<T, Prisma__vehicleClient<vehicle | null >, Prisma__vehicleClient<vehicleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DeletedServiceExpense findUnique
   */
  export type DeletedServiceExpenseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * Throw an Error if a DeletedServiceExpense can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DeletedServiceExpense to fetch.
    **/
    where: DeletedServiceExpenseWhereUniqueInput
  }


  /**
   * DeletedServiceExpense findFirst
   */
  export type DeletedServiceExpenseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * Throw an Error if a DeletedServiceExpense can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DeletedServiceExpense to fetch.
    **/
    where?: DeletedServiceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedServiceExpenses to fetch.
    **/
    orderBy?: Enumerable<DeletedServiceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedServiceExpenses.
    **/
    cursor?: DeletedServiceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedServiceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedServiceExpenses.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of DeletedServiceExpenses.
    **/
    distinct?: Enumerable<DeletedServiceExpenseScalarFieldEnum>
  }


  /**
   * DeletedServiceExpense findMany
   */
  export type DeletedServiceExpenseFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * Filter, which DeletedServiceExpenses to fetch.
    **/
    where?: DeletedServiceExpenseWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DeletedServiceExpenses to fetch.
    **/
    orderBy?: Enumerable<DeletedServiceExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedServiceExpenses.
    **/
    cursor?: DeletedServiceExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedServiceExpenses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedServiceExpenses.
    **/
    skip?: number
    distinct?: Enumerable<DeletedServiceExpenseScalarFieldEnum>
  }


  /**
   * DeletedServiceExpense create
   */
  export type DeletedServiceExpenseCreateArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * The data needed to create a DeletedServiceExpense.
    **/
    data: XOR<DeletedServiceExpenseUncheckedCreateInput, DeletedServiceExpenseCreateInput>
  }


  /**
   * DeletedServiceExpense update
   */
  export type DeletedServiceExpenseUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * The data needed to update a DeletedServiceExpense.
    **/
    data: XOR<DeletedServiceExpenseUncheckedUpdateInput, DeletedServiceExpenseUpdateInput>
    /**
     * Choose, which DeletedServiceExpense to update.
    **/
    where: DeletedServiceExpenseWhereUniqueInput
  }


  /**
   * DeletedServiceExpense updateMany
   */
  export type DeletedServiceExpenseUpdateManyArgs = {
    data: XOR<DeletedServiceExpenseUncheckedUpdateManyInput, DeletedServiceExpenseUpdateManyMutationInput>
    where?: DeletedServiceExpenseWhereInput
  }


  /**
   * DeletedServiceExpense upsert
   */
  export type DeletedServiceExpenseUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * The filter to search for the DeletedServiceExpense to update in case it exists.
    **/
    where: DeletedServiceExpenseWhereUniqueInput
    /**
     * In case the DeletedServiceExpense found by the `where` argument doesn't exist, create a new DeletedServiceExpense with this data.
    **/
    create: XOR<DeletedServiceExpenseUncheckedCreateInput, DeletedServiceExpenseCreateInput>
    /**
     * In case the DeletedServiceExpense was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<DeletedServiceExpenseUncheckedUpdateInput, DeletedServiceExpenseUpdateInput>
  }


  /**
   * DeletedServiceExpense delete
   */
  export type DeletedServiceExpenseDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
    /**
     * Filter which DeletedServiceExpense to delete.
    **/
    where: DeletedServiceExpenseWhereUniqueInput
  }


  /**
   * DeletedServiceExpense deleteMany
   */
  export type DeletedServiceExpenseDeleteManyArgs = {
    where?: DeletedServiceExpenseWhereInput
  }


  /**
   * DeletedServiceExpense without action
   */
  export type DeletedServiceExpenseArgs = {
    /**
     * Select specific fields to fetch from the DeletedServiceExpense
    **/
    select?: DeletedServiceExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DeletedServiceExpenseInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const DepartmentScalarFieldEnum: {
    departmentId: 'departmentId',
    departmentName: 'departmentName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const GarageScalarFieldEnum: {
    garageId: 'garageId',
    garageName: 'garageName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GarageScalarFieldEnum = (typeof GarageScalarFieldEnum)[keyof typeof GarageScalarFieldEnum]


  export const ItemPartScalarFieldEnum: {
    itemPart: 'itemPart',
    partName: 'partName',
    partQuantity: 'partQuantity',
    partPrice: 'partPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    supplierId: 'supplierId'
  };

  export type ItemPartScalarFieldEnum = (typeof ItemPartScalarFieldEnum)[keyof typeof ItemPartScalarFieldEnum]


  export const PartScalarFieldEnum: {
    partId: 'partId',
    partName: 'partName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartScalarFieldEnum = (typeof PartScalarFieldEnum)[keyof typeof PartScalarFieldEnum]


  export const ServiceExpenseScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    serviceDescription: 'serviceDescription',
    serviceDate: 'serviceDate',
    serviceCost: 'serviceCost',
    totalCost: 'totalCost',
    purchaseID: 'purchaseID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vehicleId: 'vehicleId',
    garageId: 'garageId'
  };

  export type ServiceExpenseScalarFieldEnum = (typeof ServiceExpenseScalarFieldEnum)[keyof typeof ServiceExpenseScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    supplierId: 'supplierId',
    supplierName: 'supplierName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    userId: 'userId',
    username: 'username',
    email: 'email',
    isAdmin: 'isAdmin',
    password: 'password'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    vehicleId: 'vehicleId',
    plateNumber: 'plateNumber',
    model: 'model',
    modelYear: 'modelYear',
    chasisNubmer: 'chasisNubmer',
    purchaseDate: 'purchaseDate',
    purchaseMileAge: 'purchaseMileAge',
    disposalDate: 'disposalDate',
    vehicleStatus: 'vehicleStatus',
    departmentId: 'departmentId',
    location: 'location',
    reason: 'reason'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const DriversScalarFieldEnum: {
    driverId: 'driverId',
    driverName: 'driverName',
    phone: 'phone',
    licensNo: 'licensNo',
    description: 'description',
    driverStatus: 'driverStatus'
  };

  export type DriversScalarFieldEnum = (typeof DriversScalarFieldEnum)[keyof typeof DriversScalarFieldEnum]


  export const DeletedItemPartScalarFieldEnum: {
    itemPart: 'itemPart',
    partName: 'partName',
    partQuantity: 'partQuantity',
    partPrice: 'partPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    supplierId: 'supplierId',
    garageId: 'garageId'
  };

  export type DeletedItemPartScalarFieldEnum = (typeof DeletedItemPartScalarFieldEnum)[keyof typeof DeletedItemPartScalarFieldEnum]


  export const DrivingScalarFieldEnum: {
    drivingId: 'drivingId',
    drivingDate: 'drivingDate',
    drivingDescription: 'drivingDescription',
    drivingStatus: 'drivingStatus',
    vehicleId: 'vehicleId',
    driverId: 'driverId',
    reason: 'reason'
  };

  export type DrivingScalarFieldEnum = (typeof DrivingScalarFieldEnum)[keyof typeof DrivingScalarFieldEnum]


  export const DeletedServiceExpenseScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    serviceDescription: 'serviceDescription',
    serviceDate: 'serviceDate',
    serviceCost: 'serviceCost',
    totalCost: 'totalCost',
    purchaseID: 'purchaseID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vehicleId: 'vehicleId',
    garageId: 'garageId'
  };

  export type DeletedServiceExpenseScalarFieldEnum = (typeof DeletedServiceExpenseScalarFieldEnum)[keyof typeof DeletedServiceExpenseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type departmentWhereInput = {
    AND?: Enumerable<departmentWhereInput>
    OR?: Enumerable<departmentWhereInput>
    NOT?: Enumerable<departmentWhereInput>
    departmentId?: IntFilter | number
    departmentName?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    vehicle?: VehicleListRelationFilter
  }

  export type departmentOrderByInput = {
    departmentId?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentWhereUniqueInput = {
    departmentId?: number
  }

  export type garageWhereInput = {
    AND?: Enumerable<garageWhereInput>
    OR?: Enumerable<garageWhereInput>
    NOT?: Enumerable<garageWhereInput>
    garageId?: IntFilter | number
    garageName?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    DeletedItemPart?: DeletedItemPartListRelationFilter
    DeletedServiceExpense?: DeletedServiceExpenseListRelationFilter
    serviceExpense?: ServiceExpenseListRelationFilter
  }

  export type garageOrderByInput = {
    garageId?: SortOrder
    garageName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type garageWhereUniqueInput = {
    garageId?: number
  }

  export type itemPartWhereInput = {
    AND?: Enumerable<itemPartWhereInput>
    OR?: Enumerable<itemPartWhereInput>
    NOT?: Enumerable<itemPartWhereInput>
    itemPart?: StringFilter | string
    partName?: StringFilter | string
    partQuantity?: IntFilter | number
    partPrice?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    id?: IntNullableFilter | number | null
    supplierId?: IntNullableFilter | number | null
    serviceExpense?: XOR<serviceExpenseWhereInput, ServiceExpenseRelationFilter> | null
    supplier?: XOR<supplierWhereInput, SupplierRelationFilter> | null
  }

  export type itemPartOrderByInput = {
    itemPart?: SortOrder
    partName?: SortOrder
    partQuantity?: SortOrder
    partPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    supplierId?: SortOrder
    serviceExpense?: serviceExpenseOrderByInput
    supplier?: supplierOrderByInput
  }

  export type itemPartWhereUniqueInput = {
    itemPart?: string
  }

  export type partWhereInput = {
    AND?: Enumerable<partWhereInput>
    OR?: Enumerable<partWhereInput>
    NOT?: Enumerable<partWhereInput>
    partId?: IntFilter | number
    partName?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type partOrderByInput = {
    partId?: SortOrder
    partName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type partWhereUniqueInput = {
    partId?: number
  }

  export type serviceExpenseWhereInput = {
    AND?: Enumerable<serviceExpenseWhereInput>
    OR?: Enumerable<serviceExpenseWhereInput>
    NOT?: Enumerable<serviceExpenseWhereInput>
    id?: IntFilter | number
    invoiceNumber?: StringFilter | string
    serviceDescription?: StringNullableFilter | string | null
    serviceDate?: DateTimeNullableFilter | Date | string | null
    serviceCost?: IntNullableFilter | number | null
    totalCost?: IntNullableFilter | number | null
    purchaseID?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    vehicleId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
    garage?: XOR<garageWhereInput, GarageRelationFilter> | null
    vehicle?: XOR<vehicleWhereInput, VehicleRelationFilter> | null
    itemPart?: ItemPartListRelationFilter
  }

  export type serviceExpenseOrderByInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    serviceDescription?: SortOrder
    serviceDate?: SortOrder
    serviceCost?: SortOrder
    totalCost?: SortOrder
    purchaseID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleId?: SortOrder
    garageId?: SortOrder
    garage?: garageOrderByInput
    vehicle?: vehicleOrderByInput
  }

  export type serviceExpenseWhereUniqueInput = {
    id?: number
    invoiceNumber?: string
  }

  export type supplierWhereInput = {
    AND?: Enumerable<supplierWhereInput>
    OR?: Enumerable<supplierWhereInput>
    NOT?: Enumerable<supplierWhereInput>
    supplierId?: IntFilter | number
    supplierName?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    DeletedItemPart?: DeletedItemPartListRelationFilter
    itemPart?: ItemPartListRelationFilter
  }

  export type supplierOrderByInput = {
    supplierId?: SortOrder
    supplierName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supplierWhereUniqueInput = {
    supplierId?: number
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    userId?: IntFilter | number
    username?: StringNullableFilter | string | null
    email?: StringFilter | string
    isAdmin?: StringFilter | string
    password?: StringFilter | string
  }

  export type usersOrderByInput = {
    userId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    isAdmin?: SortOrder
    password?: SortOrder
  }

  export type usersWhereUniqueInput = {
    userId?: number
    email?: string
  }

  export type vehicleWhereInput = {
    AND?: Enumerable<vehicleWhereInput>
    OR?: Enumerable<vehicleWhereInput>
    NOT?: Enumerable<vehicleWhereInput>
    vehicleId?: IntFilter | number
    plateNumber?: StringFilter | string
    model?: StringFilter | string
    modelYear?: IntFilter | number
    chasisNubmer?: IntFilter | number
    purchaseDate?: DateTimeFilter | Date | string
    purchaseMileAge?: IntFilter | number
    disposalDate?: DateTimeNullableFilter | Date | string | null
    vehicleStatus?: StringNullableFilter | string | null
    departmentId?: IntNullableFilter | number | null
    location?: StringNullableFilter | string | null
    reason?: StringNullableFilter | string | null
    department?: XOR<departmentWhereInput, DepartmentRelationFilter> | null
    DeletedServiceExpense?: DeletedServiceExpenseListRelationFilter
    driving?: DrivingListRelationFilter
    serviceExpense?: ServiceExpenseListRelationFilter
  }

  export type vehicleOrderByInput = {
    vehicleId?: SortOrder
    plateNumber?: SortOrder
    model?: SortOrder
    modelYear?: SortOrder
    chasisNubmer?: SortOrder
    purchaseDate?: SortOrder
    purchaseMileAge?: SortOrder
    disposalDate?: SortOrder
    vehicleStatus?: SortOrder
    departmentId?: SortOrder
    location?: SortOrder
    reason?: SortOrder
    department?: departmentOrderByInput
  }

  export type vehicleWhereUniqueInput = {
    vehicleId?: number
  }

  export type driversWhereInput = {
    AND?: Enumerable<driversWhereInput>
    OR?: Enumerable<driversWhereInput>
    NOT?: Enumerable<driversWhereInput>
    driverId?: IntFilter | number
    driverName?: StringFilter | string
    phone?: StringFilter | string
    licensNo?: IntFilter | number
    description?: StringNullableFilter | string | null
    driverStatus?: StringNullableFilter | string | null
    driving?: DrivingListRelationFilter
  }

  export type driversOrderByInput = {
    driverId?: SortOrder
    driverName?: SortOrder
    phone?: SortOrder
    licensNo?: SortOrder
    description?: SortOrder
    driverStatus?: SortOrder
  }

  export type driversWhereUniqueInput = {
    driverId?: number
  }

  export type DeletedItemPartWhereInput = {
    AND?: Enumerable<DeletedItemPartWhereInput>
    OR?: Enumerable<DeletedItemPartWhereInput>
    NOT?: Enumerable<DeletedItemPartWhereInput>
    itemPart?: StringFilter | string
    partName?: StringFilter | string
    partQuantity?: IntFilter | number
    partPrice?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    id?: IntFilter | number
    supplierId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
    garage?: XOR<garageWhereInput, GarageRelationFilter> | null
    supplier?: XOR<supplierWhereInput, SupplierRelationFilter> | null
  }

  export type DeletedItemPartOrderByInput = {
    itemPart?: SortOrder
    partName?: SortOrder
    partQuantity?: SortOrder
    partPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    supplierId?: SortOrder
    garageId?: SortOrder
    garage?: garageOrderByInput
    supplier?: supplierOrderByInput
  }

  export type DeletedItemPartWhereUniqueInput = {
    itemPart?: string
  }

  export type drivingWhereInput = {
    AND?: Enumerable<drivingWhereInput>
    OR?: Enumerable<drivingWhereInput>
    NOT?: Enumerable<drivingWhereInput>
    drivingId?: IntFilter | number
    drivingDate?: DateTimeFilter | Date | string
    drivingDescription?: StringNullableFilter | string | null
    drivingStatus?: StringNullableFilter | string | null
    vehicleId?: IntNullableFilter | number | null
    driverId?: IntNullableFilter | number | null
    reason?: StringNullableFilter | string | null
    drivers?: XOR<driversWhereInput, DriversRelationFilter> | null
    vehicle?: XOR<vehicleWhereInput, VehicleRelationFilter> | null
  }

  export type drivingOrderByInput = {
    drivingId?: SortOrder
    drivingDate?: SortOrder
    drivingDescription?: SortOrder
    drivingStatus?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    reason?: SortOrder
    drivers?: driversOrderByInput
    vehicle?: vehicleOrderByInput
  }

  export type drivingWhereUniqueInput = {
    drivingId?: number
  }

  export type DeletedServiceExpenseWhereInput = {
    AND?: Enumerable<DeletedServiceExpenseWhereInput>
    OR?: Enumerable<DeletedServiceExpenseWhereInput>
    NOT?: Enumerable<DeletedServiceExpenseWhereInput>
    id?: IntFilter | number
    invoiceNumber?: StringFilter | string
    serviceDescription?: StringNullableFilter | string | null
    serviceDate?: DateTimeNullableFilter | Date | string | null
    serviceCost?: IntNullableFilter | number | null
    totalCost?: IntNullableFilter | number | null
    purchaseID?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    vehicleId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
    garage?: XOR<garageWhereInput, GarageRelationFilter> | null
    vehicle?: XOR<vehicleWhereInput, VehicleRelationFilter> | null
  }

  export type DeletedServiceExpenseOrderByInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    serviceDescription?: SortOrder
    serviceDate?: SortOrder
    serviceCost?: SortOrder
    totalCost?: SortOrder
    purchaseID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleId?: SortOrder
    garageId?: SortOrder
    garage?: garageOrderByInput
    vehicle?: vehicleOrderByInput
  }

  export type DeletedServiceExpenseWhereUniqueInput = {
    id?: number
    invoiceNumber?: string
  }

  export type departmentCreateInput = {
    departmentName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle?: vehicleCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateInput = {
    departmentId?: number
    departmentName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle?: vehicleUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUpdateInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: vehicleUpdateManyWithoutDepartmentInput
  }

  export type departmentUncheckedUpdateInput = {
    departmentId?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: vehicleUncheckedUpdateManyWithoutDepartmentInput
  }

  export type departmentUpdateManyMutationInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departmentUncheckedUpdateManyInput = {
    departmentId?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type garageCreateInput = {
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartCreateNestedManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutGarageInput
  }

  export type garageUncheckedCreateInput = {
    garageId?: number
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedCreateNestedManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutGarageInput
  }

  export type garageUpdateInput = {
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUpdateManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUpdateManyWithoutGarageInput
  }

  export type garageUncheckedUpdateInput = {
    garageId?: IntFieldUpdateOperationsInput | number
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedUpdateManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutGarageInput
  }

  export type garageUpdateManyMutationInput = {
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type garageUncheckedUpdateManyInput = {
    garageId?: IntFieldUpdateOperationsInput | number
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemPartCreateInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    serviceExpense?: serviceExpenseCreateNestedOneWithoutItemPartInput
    supplier?: supplierCreateNestedOneWithoutItemPartInput
  }

  export type itemPartUncheckedCreateInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id?: number | null
    supplierId?: number | null
  }

  export type itemPartUpdateInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceExpense?: serviceExpenseUpdateOneWithoutItemPartInput
    supplier?: supplierUpdateOneWithoutItemPartInput
  }

  export type itemPartUncheckedUpdateInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemPartUpdateManyMutationInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemPartUncheckedUpdateManyInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type partCreateInput = {
    partName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type partUncheckedCreateInput = {
    partId?: number
    partName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type partUpdateInput = {
    partName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partUncheckedUpdateInput = {
    partId?: IntFieldUpdateOperationsInput | number
    partName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partUpdateManyMutationInput = {
    partName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partUncheckedUpdateManyInput = {
    partId?: IntFieldUpdateOperationsInput | number
    partName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceExpenseCreateInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garage?: garageCreateNestedOneWithoutServiceExpenseInput
    vehicle?: vehicleCreateNestedOneWithoutServiceExpenseInput
    itemPart?: itemPartCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicleId?: number | null
    garageId?: number | null
    itemPart?: itemPartUncheckedCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garage?: garageUpdateOneWithoutServiceExpenseInput
    vehicle?: vehicleUpdateOneWithoutServiceExpenseInput
    itemPart?: itemPartUpdateManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
    itemPart?: itemPartUncheckedUpdateManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type supplierCreateInput = {
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartCreateNestedManyWithoutSupplierInput
    itemPart?: itemPartCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    supplierId?: number
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedCreateNestedManyWithoutSupplierInput
    itemPart?: itemPartUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUpdateManyWithoutSupplierInput
    itemPart?: itemPartUpdateManyWithoutSupplierInput
  }

  export type supplierUncheckedUpdateInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedUpdateManyWithoutSupplierInput
    itemPart?: itemPartUncheckedUpdateManyWithoutSupplierInput
  }

  export type supplierUpdateManyMutationInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supplierUncheckedUpdateManyInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    username?: string | null
    email: string
    isAdmin: string
    password: string
  }

  export type usersUncheckedCreateInput = {
    userId?: number
    username?: string | null
    email: string
    isAdmin: string
    password: string
  }

  export type usersUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isAdmin?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isAdmin?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isAdmin?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isAdmin?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type vehicleCreateInput = {
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    department?: departmentCreateNestedOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutVehicleInput
    driving?: drivingCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateInput = {
    vehicleId?: number
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    departmentId?: number | null
    location?: string | null
    reason?: string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutVehicleInput
    driving?: drivingUncheckedCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUpdateInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutVehicleInput
    driving?: drivingUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutVehicleInput
    driving?: drivingUncheckedUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutVehicleInput
  }

  export type vehicleUpdateManyMutationInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicleUncheckedUpdateManyInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driversCreateInput = {
    driverName: string
    phone: string
    licensNo: number
    description?: string | null
    driverStatus?: string | null
    driving?: drivingCreateNestedManyWithoutDriversInput
  }

  export type driversUncheckedCreateInput = {
    driverId?: number
    driverName: string
    phone: string
    licensNo: number
    description?: string | null
    driverStatus?: string | null
    driving?: drivingUncheckedCreateNestedManyWithoutDriversInput
  }

  export type driversUpdateInput = {
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
    driving?: drivingUpdateManyWithoutDriversInput
  }

  export type driversUncheckedUpdateInput = {
    driverId?: IntFieldUpdateOperationsInput | number
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
    driving?: drivingUncheckedUpdateManyWithoutDriversInput
  }

  export type driversUpdateManyMutationInput = {
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driversUncheckedUpdateManyInput = {
    driverId?: IntFieldUpdateOperationsInput | number
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedItemPartCreateInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    garage?: garageCreateNestedOneWithoutDeletedItemPartInput
    supplier?: supplierCreateNestedOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedCreateInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    supplierId?: number | null
    garageId?: number | null
  }

  export type DeletedItemPartUpdateInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    garage?: garageUpdateOneWithoutDeletedItemPartInput
    supplier?: supplierUpdateOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedUpdateInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedItemPartUpdateManyMutationInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type DeletedItemPartUncheckedUpdateManyInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drivingCreateInput = {
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    reason?: string | null
    drivers?: driversCreateNestedOneWithoutDrivingInput
    vehicle?: vehicleCreateNestedOneWithoutDrivingInput
  }

  export type drivingUncheckedCreateInput = {
    drivingId?: number
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    vehicleId?: number | null
    driverId?: number | null
    reason?: string | null
  }

  export type drivingUpdateInput = {
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    drivers?: driversUpdateOneWithoutDrivingInput
    vehicle?: vehicleUpdateOneWithoutDrivingInput
  }

  export type drivingUncheckedUpdateInput = {
    drivingId?: IntFieldUpdateOperationsInput | number
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type drivingUpdateManyMutationInput = {
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type drivingUncheckedUpdateManyInput = {
    drivingId?: IntFieldUpdateOperationsInput | number
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedServiceExpenseCreateInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garage?: garageCreateNestedOneWithoutDeletedServiceExpenseInput
    vehicle?: vehicleCreateNestedOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicleId?: number | null
    garageId?: number | null
  }

  export type DeletedServiceExpenseUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garage?: garageUpdateOneWithoutDeletedServiceExpenseInput
    vehicle?: vehicleUpdateOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedServiceExpenseUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedServiceExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type VehicleListRelationFilter = {
    every?: vehicleWhereInput
    some?: vehicleWhereInput
    none?: vehicleWhereInput
  }

  export type DeletedItemPartListRelationFilter = {
    every?: DeletedItemPartWhereInput
    some?: DeletedItemPartWhereInput
    none?: DeletedItemPartWhereInput
  }

  export type DeletedServiceExpenseListRelationFilter = {
    every?: DeletedServiceExpenseWhereInput
    some?: DeletedServiceExpenseWhereInput
    none?: DeletedServiceExpenseWhereInput
  }

  export type ServiceExpenseListRelationFilter = {
    every?: serviceExpenseWhereInput
    some?: serviceExpenseWhereInput
    none?: serviceExpenseWhereInput
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ServiceExpenseRelationFilter = {
    is?: serviceExpenseWhereInput | null
    isNot?: serviceExpenseWhereInput | null
  }

  export type SupplierRelationFilter = {
    is?: supplierWhereInput | null
    isNot?: supplierWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type GarageRelationFilter = {
    is?: garageWhereInput | null
    isNot?: garageWhereInput | null
  }

  export type VehicleRelationFilter = {
    is?: vehicleWhereInput | null
    isNot?: vehicleWhereInput | null
  }

  export type ItemPartListRelationFilter = {
    every?: itemPartWhereInput
    some?: itemPartWhereInput
    none?: itemPartWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DepartmentRelationFilter = {
    is?: departmentWhereInput | null
    isNot?: departmentWhereInput | null
  }

  export type DrivingListRelationFilter = {
    every?: drivingWhereInput
    some?: drivingWhereInput
    none?: drivingWhereInput
  }

  export type DriversRelationFilter = {
    is?: driversWhereInput | null
    isNot?: driversWhereInput | null
  }

  export type vehicleCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<vehicleUncheckedCreateWithoutDepartmentInput>, Enumerable<vehicleCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<vehicleCreateOrConnectWithoutdepartmentInput>
    connect?: Enumerable<vehicleWhereUniqueInput>
  }

  export type vehicleUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<vehicleUncheckedCreateWithoutDepartmentInput>, Enumerable<vehicleCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<vehicleCreateOrConnectWithoutdepartmentInput>
    connect?: Enumerable<vehicleWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type vehicleUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<vehicleUncheckedCreateWithoutDepartmentInput>, Enumerable<vehicleCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<vehicleCreateOrConnectWithoutdepartmentInput>
    upsert?: Enumerable<vehicleUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<vehicleWhereUniqueInput>
    set?: Enumerable<vehicleWhereUniqueInput>
    disconnect?: Enumerable<vehicleWhereUniqueInput>
    delete?: Enumerable<vehicleWhereUniqueInput>
    update?: Enumerable<vehicleUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<vehicleUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<vehicleScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type vehicleUncheckedUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<vehicleUncheckedCreateWithoutDepartmentInput>, Enumerable<vehicleCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<vehicleCreateOrConnectWithoutdepartmentInput>
    upsert?: Enumerable<vehicleUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<vehicleWhereUniqueInput>
    set?: Enumerable<vehicleWhereUniqueInput>
    disconnect?: Enumerable<vehicleWhereUniqueInput>
    delete?: Enumerable<vehicleWhereUniqueInput>
    update?: Enumerable<vehicleUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<vehicleUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<vehicleScalarWhereInput>
  }

  export type DeletedItemPartCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutGarageInput>, Enumerable<DeletedItemPartCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
  }

  export type DeletedServiceExpenseCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<DeletedServiceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
  }

  export type serviceExpenseCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<serviceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
  }

  export type DeletedItemPartUncheckedCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutGarageInput>, Enumerable<DeletedItemPartCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
  }

  export type DeletedServiceExpenseUncheckedCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<DeletedServiceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
  }

  export type serviceExpenseUncheckedCreateNestedManyWithoutGarageInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<serviceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutgarageInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
  }

  export type DeletedItemPartUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutGarageInput>, Enumerable<DeletedItemPartCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<DeletedItemPartUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
    set?: Enumerable<DeletedItemPartWhereUniqueInput>
    disconnect?: Enumerable<DeletedItemPartWhereUniqueInput>
    delete?: Enumerable<DeletedItemPartWhereUniqueInput>
    update?: Enumerable<DeletedItemPartUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<DeletedItemPartUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<DeletedItemPartScalarWhereInput>
  }

  export type DeletedServiceExpenseUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<DeletedServiceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<DeletedServiceExpenseUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    set?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    disconnect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    delete?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    update?: Enumerable<DeletedServiceExpenseUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<DeletedServiceExpenseUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<DeletedServiceExpenseScalarWhereInput>
  }

  export type serviceExpenseUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<serviceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<serviceExpenseUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
    set?: Enumerable<serviceExpenseWhereUniqueInput>
    disconnect?: Enumerable<serviceExpenseWhereUniqueInput>
    delete?: Enumerable<serviceExpenseWhereUniqueInput>
    update?: Enumerable<serviceExpenseUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<serviceExpenseUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<serviceExpenseScalarWhereInput>
  }

  export type DeletedItemPartUncheckedUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutGarageInput>, Enumerable<DeletedItemPartCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<DeletedItemPartUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
    set?: Enumerable<DeletedItemPartWhereUniqueInput>
    disconnect?: Enumerable<DeletedItemPartWhereUniqueInput>
    delete?: Enumerable<DeletedItemPartWhereUniqueInput>
    update?: Enumerable<DeletedItemPartUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<DeletedItemPartUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<DeletedItemPartScalarWhereInput>
  }

  export type DeletedServiceExpenseUncheckedUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<DeletedServiceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<DeletedServiceExpenseUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    set?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    disconnect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    delete?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    update?: Enumerable<DeletedServiceExpenseUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<DeletedServiceExpenseUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<DeletedServiceExpenseScalarWhereInput>
  }

  export type serviceExpenseUncheckedUpdateManyWithoutGarageInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutGarageInput>, Enumerable<serviceExpenseCreateWithoutGarageInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutgarageInput>
    upsert?: Enumerable<serviceExpenseUpsertWithWhereUniqueWithoutGarageInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
    set?: Enumerable<serviceExpenseWhereUniqueInput>
    disconnect?: Enumerable<serviceExpenseWhereUniqueInput>
    delete?: Enumerable<serviceExpenseWhereUniqueInput>
    update?: Enumerable<serviceExpenseUpdateWithWhereUniqueWithoutGarageInput>
    updateMany?: Enumerable<serviceExpenseUpdateManyWithWhereWithoutGarageInput>
    deleteMany?: Enumerable<serviceExpenseScalarWhereInput>
  }

  export type serviceExpenseCreateNestedOneWithoutItemPartInput = {
    create?: XOR<serviceExpenseUncheckedCreateWithoutItemPartInput, serviceExpenseCreateWithoutItemPartInput>
    connectOrCreate?: serviceExpenseCreateOrConnectWithoutitemPartInput
    connect?: serviceExpenseWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutItemPartInput = {
    create?: XOR<supplierUncheckedCreateWithoutItemPartInput, supplierCreateWithoutItemPartInput>
    connectOrCreate?: supplierCreateOrConnectWithoutitemPartInput
    connect?: supplierWhereUniqueInput
  }

  export type serviceExpenseUpdateOneWithoutItemPartInput = {
    create?: XOR<serviceExpenseUncheckedCreateWithoutItemPartInput, serviceExpenseCreateWithoutItemPartInput>
    connectOrCreate?: serviceExpenseCreateOrConnectWithoutitemPartInput
    upsert?: serviceExpenseUpsertWithoutItemPartInput
    connect?: serviceExpenseWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<serviceExpenseUncheckedUpdateWithoutItemPartInput, serviceExpenseUpdateWithoutItemPartInput>
  }

  export type supplierUpdateOneWithoutItemPartInput = {
    create?: XOR<supplierUncheckedCreateWithoutItemPartInput, supplierCreateWithoutItemPartInput>
    connectOrCreate?: supplierCreateOrConnectWithoutitemPartInput
    upsert?: supplierUpsertWithoutItemPartInput
    connect?: supplierWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<supplierUncheckedUpdateWithoutItemPartInput, supplierUpdateWithoutItemPartInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type garageCreateNestedOneWithoutServiceExpenseInput = {
    create?: XOR<garageUncheckedCreateWithoutServiceExpenseInput, garageCreateWithoutServiceExpenseInput>
    connectOrCreate?: garageCreateOrConnectWithoutserviceExpenseInput
    connect?: garageWhereUniqueInput
  }

  export type vehicleCreateNestedOneWithoutServiceExpenseInput = {
    create?: XOR<vehicleUncheckedCreateWithoutServiceExpenseInput, vehicleCreateWithoutServiceExpenseInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutserviceExpenseInput
    connect?: vehicleWhereUniqueInput
  }

  export type itemPartCreateNestedManyWithoutServiceExpenseInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutServiceExpenseInput>, Enumerable<itemPartCreateWithoutServiceExpenseInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutserviceExpenseInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
  }

  export type itemPartUncheckedCreateNestedManyWithoutServiceExpenseInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutServiceExpenseInput>, Enumerable<itemPartCreateWithoutServiceExpenseInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutserviceExpenseInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type garageUpdateOneWithoutServiceExpenseInput = {
    create?: XOR<garageUncheckedCreateWithoutServiceExpenseInput, garageCreateWithoutServiceExpenseInput>
    connectOrCreate?: garageCreateOrConnectWithoutserviceExpenseInput
    upsert?: garageUpsertWithoutServiceExpenseInput
    connect?: garageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<garageUncheckedUpdateWithoutServiceExpenseInput, garageUpdateWithoutServiceExpenseInput>
  }

  export type vehicleUpdateOneWithoutServiceExpenseInput = {
    create?: XOR<vehicleUncheckedCreateWithoutServiceExpenseInput, vehicleCreateWithoutServiceExpenseInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutserviceExpenseInput
    upsert?: vehicleUpsertWithoutServiceExpenseInput
    connect?: vehicleWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<vehicleUncheckedUpdateWithoutServiceExpenseInput, vehicleUpdateWithoutServiceExpenseInput>
  }

  export type itemPartUpdateManyWithoutServiceExpenseInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutServiceExpenseInput>, Enumerable<itemPartCreateWithoutServiceExpenseInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutserviceExpenseInput>
    upsert?: Enumerable<itemPartUpsertWithWhereUniqueWithoutServiceExpenseInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
    set?: Enumerable<itemPartWhereUniqueInput>
    disconnect?: Enumerable<itemPartWhereUniqueInput>
    delete?: Enumerable<itemPartWhereUniqueInput>
    update?: Enumerable<itemPartUpdateWithWhereUniqueWithoutServiceExpenseInput>
    updateMany?: Enumerable<itemPartUpdateManyWithWhereWithoutServiceExpenseInput>
    deleteMany?: Enumerable<itemPartScalarWhereInput>
  }

  export type itemPartUncheckedUpdateManyWithoutServiceExpenseInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutServiceExpenseInput>, Enumerable<itemPartCreateWithoutServiceExpenseInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutserviceExpenseInput>
    upsert?: Enumerable<itemPartUpsertWithWhereUniqueWithoutServiceExpenseInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
    set?: Enumerable<itemPartWhereUniqueInput>
    disconnect?: Enumerable<itemPartWhereUniqueInput>
    delete?: Enumerable<itemPartWhereUniqueInput>
    update?: Enumerable<itemPartUpdateWithWhereUniqueWithoutServiceExpenseInput>
    updateMany?: Enumerable<itemPartUpdateManyWithWhereWithoutServiceExpenseInput>
    deleteMany?: Enumerable<itemPartScalarWhereInput>
  }

  export type DeletedItemPartCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutSupplierInput>, Enumerable<DeletedItemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutsupplierInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
  }

  export type itemPartCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutSupplierInput>, Enumerable<itemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutsupplierInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
  }

  export type DeletedItemPartUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutSupplierInput>, Enumerable<DeletedItemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutsupplierInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
  }

  export type itemPartUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutSupplierInput>, Enumerable<itemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutsupplierInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
  }

  export type DeletedItemPartUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutSupplierInput>, Enumerable<DeletedItemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutsupplierInput>
    upsert?: Enumerable<DeletedItemPartUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
    set?: Enumerable<DeletedItemPartWhereUniqueInput>
    disconnect?: Enumerable<DeletedItemPartWhereUniqueInput>
    delete?: Enumerable<DeletedItemPartWhereUniqueInput>
    update?: Enumerable<DeletedItemPartUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<DeletedItemPartUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<DeletedItemPartScalarWhereInput>
  }

  export type itemPartUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutSupplierInput>, Enumerable<itemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutsupplierInput>
    upsert?: Enumerable<itemPartUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
    set?: Enumerable<itemPartWhereUniqueInput>
    disconnect?: Enumerable<itemPartWhereUniqueInput>
    delete?: Enumerable<itemPartWhereUniqueInput>
    update?: Enumerable<itemPartUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<itemPartUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<itemPartScalarWhereInput>
  }

  export type DeletedItemPartUncheckedUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<DeletedItemPartUncheckedCreateWithoutSupplierInput>, Enumerable<DeletedItemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<DeletedItemPartCreateOrConnectWithoutsupplierInput>
    upsert?: Enumerable<DeletedItemPartUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<DeletedItemPartWhereUniqueInput>
    set?: Enumerable<DeletedItemPartWhereUniqueInput>
    disconnect?: Enumerable<DeletedItemPartWhereUniqueInput>
    delete?: Enumerable<DeletedItemPartWhereUniqueInput>
    update?: Enumerable<DeletedItemPartUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<DeletedItemPartUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<DeletedItemPartScalarWhereInput>
  }

  export type itemPartUncheckedUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<itemPartUncheckedCreateWithoutSupplierInput>, Enumerable<itemPartCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<itemPartCreateOrConnectWithoutsupplierInput>
    upsert?: Enumerable<itemPartUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<itemPartWhereUniqueInput>
    set?: Enumerable<itemPartWhereUniqueInput>
    disconnect?: Enumerable<itemPartWhereUniqueInput>
    delete?: Enumerable<itemPartWhereUniqueInput>
    update?: Enumerable<itemPartUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<itemPartUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<itemPartScalarWhereInput>
  }

  export type departmentCreateNestedOneWithoutVehicleInput = {
    create?: XOR<departmentUncheckedCreateWithoutVehicleInput, departmentCreateWithoutVehicleInput>
    connectOrCreate?: departmentCreateOrConnectWithoutvehicleInput
    connect?: departmentWhereUniqueInput
  }

  export type DeletedServiceExpenseCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<DeletedServiceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
  }

  export type drivingCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutVehicleInput>, Enumerable<drivingCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<drivingWhereUniqueInput>
  }

  export type serviceExpenseCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<serviceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
  }

  export type DeletedServiceExpenseUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<DeletedServiceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
  }

  export type drivingUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutVehicleInput>, Enumerable<drivingCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<drivingWhereUniqueInput>
  }

  export type serviceExpenseUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<serviceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutvehicleInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type departmentUpdateOneWithoutVehicleInput = {
    create?: XOR<departmentUncheckedCreateWithoutVehicleInput, departmentCreateWithoutVehicleInput>
    connectOrCreate?: departmentCreateOrConnectWithoutvehicleInput
    upsert?: departmentUpsertWithoutVehicleInput
    connect?: departmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<departmentUncheckedUpdateWithoutVehicleInput, departmentUpdateWithoutVehicleInput>
  }

  export type DeletedServiceExpenseUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<DeletedServiceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<DeletedServiceExpenseUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    set?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    disconnect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    delete?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    update?: Enumerable<DeletedServiceExpenseUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<DeletedServiceExpenseUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<DeletedServiceExpenseScalarWhereInput>
  }

  export type drivingUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutVehicleInput>, Enumerable<drivingCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<drivingUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<drivingWhereUniqueInput>
    set?: Enumerable<drivingWhereUniqueInput>
    disconnect?: Enumerable<drivingWhereUniqueInput>
    delete?: Enumerable<drivingWhereUniqueInput>
    update?: Enumerable<drivingUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<drivingUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<drivingScalarWhereInput>
  }

  export type serviceExpenseUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<serviceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<serviceExpenseUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
    set?: Enumerable<serviceExpenseWhereUniqueInput>
    disconnect?: Enumerable<serviceExpenseWhereUniqueInput>
    delete?: Enumerable<serviceExpenseWhereUniqueInput>
    update?: Enumerable<serviceExpenseUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<serviceExpenseUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<serviceExpenseScalarWhereInput>
  }

  export type DeletedServiceExpenseUncheckedUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<DeletedServiceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<DeletedServiceExpenseCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<DeletedServiceExpenseUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    set?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    disconnect?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    delete?: Enumerable<DeletedServiceExpenseWhereUniqueInput>
    update?: Enumerable<DeletedServiceExpenseUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<DeletedServiceExpenseUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<DeletedServiceExpenseScalarWhereInput>
  }

  export type drivingUncheckedUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutVehicleInput>, Enumerable<drivingCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<drivingUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<drivingWhereUniqueInput>
    set?: Enumerable<drivingWhereUniqueInput>
    disconnect?: Enumerable<drivingWhereUniqueInput>
    delete?: Enumerable<drivingWhereUniqueInput>
    update?: Enumerable<drivingUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<drivingUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<drivingScalarWhereInput>
  }

  export type serviceExpenseUncheckedUpdateManyWithoutVehicleInput = {
    create?: XOR<Enumerable<serviceExpenseUncheckedCreateWithoutVehicleInput>, Enumerable<serviceExpenseCreateWithoutVehicleInput>>
    connectOrCreate?: Enumerable<serviceExpenseCreateOrConnectWithoutvehicleInput>
    upsert?: Enumerable<serviceExpenseUpsertWithWhereUniqueWithoutVehicleInput>
    connect?: Enumerable<serviceExpenseWhereUniqueInput>
    set?: Enumerable<serviceExpenseWhereUniqueInput>
    disconnect?: Enumerable<serviceExpenseWhereUniqueInput>
    delete?: Enumerable<serviceExpenseWhereUniqueInput>
    update?: Enumerable<serviceExpenseUpdateWithWhereUniqueWithoutVehicleInput>
    updateMany?: Enumerable<serviceExpenseUpdateManyWithWhereWithoutVehicleInput>
    deleteMany?: Enumerable<serviceExpenseScalarWhereInput>
  }

  export type drivingCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutDriversInput>, Enumerable<drivingCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutdriversInput>
    connect?: Enumerable<drivingWhereUniqueInput>
  }

  export type drivingUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutDriversInput>, Enumerable<drivingCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutdriversInput>
    connect?: Enumerable<drivingWhereUniqueInput>
  }

  export type drivingUpdateManyWithoutDriversInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutDriversInput>, Enumerable<drivingCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutdriversInput>
    upsert?: Enumerable<drivingUpsertWithWhereUniqueWithoutDriversInput>
    connect?: Enumerable<drivingWhereUniqueInput>
    set?: Enumerable<drivingWhereUniqueInput>
    disconnect?: Enumerable<drivingWhereUniqueInput>
    delete?: Enumerable<drivingWhereUniqueInput>
    update?: Enumerable<drivingUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<drivingUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<drivingScalarWhereInput>
  }

  export type drivingUncheckedUpdateManyWithoutDriversInput = {
    create?: XOR<Enumerable<drivingUncheckedCreateWithoutDriversInput>, Enumerable<drivingCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<drivingCreateOrConnectWithoutdriversInput>
    upsert?: Enumerable<drivingUpsertWithWhereUniqueWithoutDriversInput>
    connect?: Enumerable<drivingWhereUniqueInput>
    set?: Enumerable<drivingWhereUniqueInput>
    disconnect?: Enumerable<drivingWhereUniqueInput>
    delete?: Enumerable<drivingWhereUniqueInput>
    update?: Enumerable<drivingUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<drivingUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<drivingScalarWhereInput>
  }

  export type garageCreateNestedOneWithoutDeletedItemPartInput = {
    create?: XOR<garageUncheckedCreateWithoutDeletedItemPartInput, garageCreateWithoutDeletedItemPartInput>
    connectOrCreate?: garageCreateOrConnectWithoutDeletedItemPartInput
    connect?: garageWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutDeletedItemPartInput = {
    create?: XOR<supplierUncheckedCreateWithoutDeletedItemPartInput, supplierCreateWithoutDeletedItemPartInput>
    connectOrCreate?: supplierCreateOrConnectWithoutDeletedItemPartInput
    connect?: supplierWhereUniqueInput
  }

  export type garageUpdateOneWithoutDeletedItemPartInput = {
    create?: XOR<garageUncheckedCreateWithoutDeletedItemPartInput, garageCreateWithoutDeletedItemPartInput>
    connectOrCreate?: garageCreateOrConnectWithoutDeletedItemPartInput
    upsert?: garageUpsertWithoutDeletedItemPartInput
    connect?: garageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<garageUncheckedUpdateWithoutDeletedItemPartInput, garageUpdateWithoutDeletedItemPartInput>
  }

  export type supplierUpdateOneWithoutDeletedItemPartInput = {
    create?: XOR<supplierUncheckedCreateWithoutDeletedItemPartInput, supplierCreateWithoutDeletedItemPartInput>
    connectOrCreate?: supplierCreateOrConnectWithoutDeletedItemPartInput
    upsert?: supplierUpsertWithoutDeletedItemPartInput
    connect?: supplierWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<supplierUncheckedUpdateWithoutDeletedItemPartInput, supplierUpdateWithoutDeletedItemPartInput>
  }

  export type driversCreateNestedOneWithoutDrivingInput = {
    create?: XOR<driversUncheckedCreateWithoutDrivingInput, driversCreateWithoutDrivingInput>
    connectOrCreate?: driversCreateOrConnectWithoutdrivingInput
    connect?: driversWhereUniqueInput
  }

  export type vehicleCreateNestedOneWithoutDrivingInput = {
    create?: XOR<vehicleUncheckedCreateWithoutDrivingInput, vehicleCreateWithoutDrivingInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutdrivingInput
    connect?: vehicleWhereUniqueInput
  }

  export type driversUpdateOneWithoutDrivingInput = {
    create?: XOR<driversUncheckedCreateWithoutDrivingInput, driversCreateWithoutDrivingInput>
    connectOrCreate?: driversCreateOrConnectWithoutdrivingInput
    upsert?: driversUpsertWithoutDrivingInput
    connect?: driversWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<driversUncheckedUpdateWithoutDrivingInput, driversUpdateWithoutDrivingInput>
  }

  export type vehicleUpdateOneWithoutDrivingInput = {
    create?: XOR<vehicleUncheckedCreateWithoutDrivingInput, vehicleCreateWithoutDrivingInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutdrivingInput
    upsert?: vehicleUpsertWithoutDrivingInput
    connect?: vehicleWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<vehicleUncheckedUpdateWithoutDrivingInput, vehicleUpdateWithoutDrivingInput>
  }

  export type garageCreateNestedOneWithoutDeletedServiceExpenseInput = {
    create?: XOR<garageUncheckedCreateWithoutDeletedServiceExpenseInput, garageCreateWithoutDeletedServiceExpenseInput>
    connectOrCreate?: garageCreateOrConnectWithoutDeletedServiceExpenseInput
    connect?: garageWhereUniqueInput
  }

  export type vehicleCreateNestedOneWithoutDeletedServiceExpenseInput = {
    create?: XOR<vehicleUncheckedCreateWithoutDeletedServiceExpenseInput, vehicleCreateWithoutDeletedServiceExpenseInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutDeletedServiceExpenseInput
    connect?: vehicleWhereUniqueInput
  }

  export type garageUpdateOneWithoutDeletedServiceExpenseInput = {
    create?: XOR<garageUncheckedCreateWithoutDeletedServiceExpenseInput, garageCreateWithoutDeletedServiceExpenseInput>
    connectOrCreate?: garageCreateOrConnectWithoutDeletedServiceExpenseInput
    upsert?: garageUpsertWithoutDeletedServiceExpenseInput
    connect?: garageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<garageUncheckedUpdateWithoutDeletedServiceExpenseInput, garageUpdateWithoutDeletedServiceExpenseInput>
  }

  export type vehicleUpdateOneWithoutDeletedServiceExpenseInput = {
    create?: XOR<vehicleUncheckedCreateWithoutDeletedServiceExpenseInput, vehicleCreateWithoutDeletedServiceExpenseInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutDeletedServiceExpenseInput
    upsert?: vehicleUpsertWithoutDeletedServiceExpenseInput
    connect?: vehicleWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<vehicleUncheckedUpdateWithoutDeletedServiceExpenseInput, vehicleUpdateWithoutDeletedServiceExpenseInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type vehicleCreateWithoutDepartmentInput = {
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutVehicleInput
    driving?: drivingCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutDepartmentInput = {
    vehicleId?: number
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutVehicleInput
    driving?: drivingUncheckedCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutdepartmentInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleUncheckedCreateWithoutDepartmentInput, vehicleCreateWithoutDepartmentInput>
  }

  export type vehicleUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: vehicleWhereUniqueInput
    update: XOR<vehicleUncheckedUpdateWithoutDepartmentInput, vehicleUpdateWithoutDepartmentInput>
    create: XOR<vehicleUncheckedCreateWithoutDepartmentInput, vehicleCreateWithoutDepartmentInput>
  }

  export type vehicleUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: vehicleWhereUniqueInput
    data: XOR<vehicleUncheckedUpdateWithoutDepartmentInput, vehicleUpdateWithoutDepartmentInput>
  }

  export type vehicleUpdateManyWithWhereWithoutDepartmentInput = {
    where: vehicleScalarWhereInput
    data: XOR<vehicleUncheckedUpdateManyWithoutVehicleInput, vehicleUpdateManyMutationInput>
  }

  export type vehicleScalarWhereInput = {
    AND?: Enumerable<vehicleScalarWhereInput>
    OR?: Enumerable<vehicleScalarWhereInput>
    NOT?: Enumerable<vehicleScalarWhereInput>
    vehicleId?: IntFilter | number
    plateNumber?: StringFilter | string
    model?: StringFilter | string
    modelYear?: IntFilter | number
    chasisNubmer?: IntFilter | number
    purchaseDate?: DateTimeFilter | Date | string
    purchaseMileAge?: IntFilter | number
    disposalDate?: DateTimeNullableFilter | Date | string | null
    vehicleStatus?: StringNullableFilter | string | null
    departmentId?: IntNullableFilter | number | null
    location?: StringNullableFilter | string | null
    reason?: StringNullableFilter | string | null
  }

  export type DeletedItemPartCreateWithoutGarageInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    supplier?: supplierCreateNestedOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedCreateWithoutGarageInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    supplierId?: number | null
  }

  export type DeletedItemPartCreateOrConnectWithoutgarageInput = {
    where: DeletedItemPartWhereUniqueInput
    create: XOR<DeletedItemPartUncheckedCreateWithoutGarageInput, DeletedItemPartCreateWithoutGarageInput>
  }

  export type DeletedServiceExpenseCreateWithoutGarageInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle?: vehicleCreateNestedOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedCreateWithoutGarageInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicleId?: number | null
  }

  export type DeletedServiceExpenseCreateOrConnectWithoutgarageInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    create: XOR<DeletedServiceExpenseUncheckedCreateWithoutGarageInput, DeletedServiceExpenseCreateWithoutGarageInput>
  }

  export type serviceExpenseCreateWithoutGarageInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle?: vehicleCreateNestedOneWithoutServiceExpenseInput
    itemPart?: itemPartCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedCreateWithoutGarageInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicleId?: number | null
    itemPart?: itemPartUncheckedCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseCreateOrConnectWithoutgarageInput = {
    where: serviceExpenseWhereUniqueInput
    create: XOR<serviceExpenseUncheckedCreateWithoutGarageInput, serviceExpenseCreateWithoutGarageInput>
  }

  export type DeletedItemPartUpsertWithWhereUniqueWithoutGarageInput = {
    where: DeletedItemPartWhereUniqueInput
    update: XOR<DeletedItemPartUncheckedUpdateWithoutGarageInput, DeletedItemPartUpdateWithoutGarageInput>
    create: XOR<DeletedItemPartUncheckedCreateWithoutGarageInput, DeletedItemPartCreateWithoutGarageInput>
  }

  export type DeletedItemPartUpdateWithWhereUniqueWithoutGarageInput = {
    where: DeletedItemPartWhereUniqueInput
    data: XOR<DeletedItemPartUncheckedUpdateWithoutGarageInput, DeletedItemPartUpdateWithoutGarageInput>
  }

  export type DeletedItemPartUpdateManyWithWhereWithoutGarageInput = {
    where: DeletedItemPartScalarWhereInput
    data: XOR<DeletedItemPartUncheckedUpdateManyWithoutDeletedItemPartInput, DeletedItemPartUpdateManyMutationInput>
  }

  export type DeletedItemPartScalarWhereInput = {
    AND?: Enumerable<DeletedItemPartScalarWhereInput>
    OR?: Enumerable<DeletedItemPartScalarWhereInput>
    NOT?: Enumerable<DeletedItemPartScalarWhereInput>
    itemPart?: StringFilter | string
    partName?: StringFilter | string
    partQuantity?: IntFilter | number
    partPrice?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    id?: IntFilter | number
    supplierId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
  }

  export type DeletedServiceExpenseUpsertWithWhereUniqueWithoutGarageInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    update: XOR<DeletedServiceExpenseUncheckedUpdateWithoutGarageInput, DeletedServiceExpenseUpdateWithoutGarageInput>
    create: XOR<DeletedServiceExpenseUncheckedCreateWithoutGarageInput, DeletedServiceExpenseCreateWithoutGarageInput>
  }

  export type DeletedServiceExpenseUpdateWithWhereUniqueWithoutGarageInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    data: XOR<DeletedServiceExpenseUncheckedUpdateWithoutGarageInput, DeletedServiceExpenseUpdateWithoutGarageInput>
  }

  export type DeletedServiceExpenseUpdateManyWithWhereWithoutGarageInput = {
    where: DeletedServiceExpenseScalarWhereInput
    data: XOR<DeletedServiceExpenseUncheckedUpdateManyWithoutDeletedServiceExpenseInput, DeletedServiceExpenseUpdateManyMutationInput>
  }

  export type DeletedServiceExpenseScalarWhereInput = {
    AND?: Enumerable<DeletedServiceExpenseScalarWhereInput>
    OR?: Enumerable<DeletedServiceExpenseScalarWhereInput>
    NOT?: Enumerable<DeletedServiceExpenseScalarWhereInput>
    id?: IntFilter | number
    invoiceNumber?: StringFilter | string
    serviceDescription?: StringNullableFilter | string | null
    serviceDate?: DateTimeNullableFilter | Date | string | null
    serviceCost?: IntNullableFilter | number | null
    totalCost?: IntNullableFilter | number | null
    purchaseID?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    vehicleId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
  }

  export type serviceExpenseUpsertWithWhereUniqueWithoutGarageInput = {
    where: serviceExpenseWhereUniqueInput
    update: XOR<serviceExpenseUncheckedUpdateWithoutGarageInput, serviceExpenseUpdateWithoutGarageInput>
    create: XOR<serviceExpenseUncheckedCreateWithoutGarageInput, serviceExpenseCreateWithoutGarageInput>
  }

  export type serviceExpenseUpdateWithWhereUniqueWithoutGarageInput = {
    where: serviceExpenseWhereUniqueInput
    data: XOR<serviceExpenseUncheckedUpdateWithoutGarageInput, serviceExpenseUpdateWithoutGarageInput>
  }

  export type serviceExpenseUpdateManyWithWhereWithoutGarageInput = {
    where: serviceExpenseScalarWhereInput
    data: XOR<serviceExpenseUncheckedUpdateManyWithoutServiceExpenseInput, serviceExpenseUpdateManyMutationInput>
  }

  export type serviceExpenseScalarWhereInput = {
    AND?: Enumerable<serviceExpenseScalarWhereInput>
    OR?: Enumerable<serviceExpenseScalarWhereInput>
    NOT?: Enumerable<serviceExpenseScalarWhereInput>
    id?: IntFilter | number
    invoiceNumber?: StringFilter | string
    serviceDescription?: StringNullableFilter | string | null
    serviceDate?: DateTimeNullableFilter | Date | string | null
    serviceCost?: IntNullableFilter | number | null
    totalCost?: IntNullableFilter | number | null
    purchaseID?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    vehicleId?: IntNullableFilter | number | null
    garageId?: IntNullableFilter | number | null
  }

  export type serviceExpenseCreateWithoutItemPartInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garage?: garageCreateNestedOneWithoutServiceExpenseInput
    vehicle?: vehicleCreateNestedOneWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedCreateWithoutItemPartInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicleId?: number | null
    garageId?: number | null
  }

  export type serviceExpenseCreateOrConnectWithoutitemPartInput = {
    where: serviceExpenseWhereUniqueInput
    create: XOR<serviceExpenseUncheckedCreateWithoutItemPartInput, serviceExpenseCreateWithoutItemPartInput>
  }

  export type supplierCreateWithoutItemPartInput = {
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutItemPartInput = {
    supplierId?: number
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutitemPartInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierUncheckedCreateWithoutItemPartInput, supplierCreateWithoutItemPartInput>
  }

  export type serviceExpenseUpsertWithoutItemPartInput = {
    update: XOR<serviceExpenseUncheckedUpdateWithoutItemPartInput, serviceExpenseUpdateWithoutItemPartInput>
    create: XOR<serviceExpenseUncheckedCreateWithoutItemPartInput, serviceExpenseCreateWithoutItemPartInput>
  }

  export type serviceExpenseUpdateWithoutItemPartInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garage?: garageUpdateOneWithoutServiceExpenseInput
    vehicle?: vehicleUpdateOneWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedUpdateWithoutItemPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type supplierUpsertWithoutItemPartInput = {
    update: XOR<supplierUncheckedUpdateWithoutItemPartInput, supplierUpdateWithoutItemPartInput>
    create: XOR<supplierUncheckedCreateWithoutItemPartInput, supplierCreateWithoutItemPartInput>
  }

  export type supplierUpdateWithoutItemPartInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUpdateManyWithoutSupplierInput
  }

  export type supplierUncheckedUpdateWithoutItemPartInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedUpdateManyWithoutSupplierInput
  }

  export type garageCreateWithoutServiceExpenseInput = {
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartCreateNestedManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutGarageInput
  }

  export type garageUncheckedCreateWithoutServiceExpenseInput = {
    garageId?: number
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedCreateNestedManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutGarageInput
  }

  export type garageCreateOrConnectWithoutserviceExpenseInput = {
    where: garageWhereUniqueInput
    create: XOR<garageUncheckedCreateWithoutServiceExpenseInput, garageCreateWithoutServiceExpenseInput>
  }

  export type vehicleCreateWithoutServiceExpenseInput = {
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    department?: departmentCreateNestedOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutVehicleInput
    driving?: drivingCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutServiceExpenseInput = {
    vehicleId?: number
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    departmentId?: number | null
    location?: string | null
    reason?: string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutVehicleInput
    driving?: drivingUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutserviceExpenseInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleUncheckedCreateWithoutServiceExpenseInput, vehicleCreateWithoutServiceExpenseInput>
  }

  export type itemPartCreateWithoutServiceExpenseInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    supplier?: supplierCreateNestedOneWithoutItemPartInput
  }

  export type itemPartUncheckedCreateWithoutServiceExpenseInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    supplierId?: number | null
  }

  export type itemPartCreateOrConnectWithoutserviceExpenseInput = {
    where: itemPartWhereUniqueInput
    create: XOR<itemPartUncheckedCreateWithoutServiceExpenseInput, itemPartCreateWithoutServiceExpenseInput>
  }

  export type garageUpsertWithoutServiceExpenseInput = {
    update: XOR<garageUncheckedUpdateWithoutServiceExpenseInput, garageUpdateWithoutServiceExpenseInput>
    create: XOR<garageUncheckedCreateWithoutServiceExpenseInput, garageCreateWithoutServiceExpenseInput>
  }

  export type garageUpdateWithoutServiceExpenseInput = {
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUpdateManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutGarageInput
  }

  export type garageUncheckedUpdateWithoutServiceExpenseInput = {
    garageId?: IntFieldUpdateOperationsInput | number
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedUpdateManyWithoutGarageInput
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutGarageInput
  }

  export type vehicleUpsertWithoutServiceExpenseInput = {
    update: XOR<vehicleUncheckedUpdateWithoutServiceExpenseInput, vehicleUpdateWithoutServiceExpenseInput>
    create: XOR<vehicleUncheckedCreateWithoutServiceExpenseInput, vehicleCreateWithoutServiceExpenseInput>
  }

  export type vehicleUpdateWithoutServiceExpenseInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutVehicleInput
    driving?: drivingUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateWithoutServiceExpenseInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutVehicleInput
    driving?: drivingUncheckedUpdateManyWithoutVehicleInput
  }

  export type itemPartUpsertWithWhereUniqueWithoutServiceExpenseInput = {
    where: itemPartWhereUniqueInput
    update: XOR<itemPartUncheckedUpdateWithoutServiceExpenseInput, itemPartUpdateWithoutServiceExpenseInput>
    create: XOR<itemPartUncheckedCreateWithoutServiceExpenseInput, itemPartCreateWithoutServiceExpenseInput>
  }

  export type itemPartUpdateWithWhereUniqueWithoutServiceExpenseInput = {
    where: itemPartWhereUniqueInput
    data: XOR<itemPartUncheckedUpdateWithoutServiceExpenseInput, itemPartUpdateWithoutServiceExpenseInput>
  }

  export type itemPartUpdateManyWithWhereWithoutServiceExpenseInput = {
    where: itemPartScalarWhereInput
    data: XOR<itemPartUncheckedUpdateManyWithoutItemPartInput, itemPartUpdateManyMutationInput>
  }

  export type itemPartScalarWhereInput = {
    AND?: Enumerable<itemPartScalarWhereInput>
    OR?: Enumerable<itemPartScalarWhereInput>
    NOT?: Enumerable<itemPartScalarWhereInput>
    itemPart?: StringFilter | string
    partName?: StringFilter | string
    partQuantity?: IntFilter | number
    partPrice?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    id?: IntNullableFilter | number | null
    supplierId?: IntNullableFilter | number | null
  }

  export type DeletedItemPartCreateWithoutSupplierInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    garage?: garageCreateNestedOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedCreateWithoutSupplierInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id: number
    garageId?: number | null
  }

  export type DeletedItemPartCreateOrConnectWithoutsupplierInput = {
    where: DeletedItemPartWhereUniqueInput
    create: XOR<DeletedItemPartUncheckedCreateWithoutSupplierInput, DeletedItemPartCreateWithoutSupplierInput>
  }

  export type itemPartCreateWithoutSupplierInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    serviceExpense?: serviceExpenseCreateNestedOneWithoutItemPartInput
  }

  export type itemPartUncheckedCreateWithoutSupplierInput = {
    itemPart: string
    partName: string
    partQuantity: number
    partPrice: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    id?: number | null
  }

  export type itemPartCreateOrConnectWithoutsupplierInput = {
    where: itemPartWhereUniqueInput
    create: XOR<itemPartUncheckedCreateWithoutSupplierInput, itemPartCreateWithoutSupplierInput>
  }

  export type DeletedItemPartUpsertWithWhereUniqueWithoutSupplierInput = {
    where: DeletedItemPartWhereUniqueInput
    update: XOR<DeletedItemPartUncheckedUpdateWithoutSupplierInput, DeletedItemPartUpdateWithoutSupplierInput>
    create: XOR<DeletedItemPartUncheckedCreateWithoutSupplierInput, DeletedItemPartCreateWithoutSupplierInput>
  }

  export type DeletedItemPartUpdateWithWhereUniqueWithoutSupplierInput = {
    where: DeletedItemPartWhereUniqueInput
    data: XOR<DeletedItemPartUncheckedUpdateWithoutSupplierInput, DeletedItemPartUpdateWithoutSupplierInput>
  }

  export type DeletedItemPartUpdateManyWithWhereWithoutSupplierInput = {
    where: DeletedItemPartScalarWhereInput
    data: XOR<DeletedItemPartUncheckedUpdateManyWithoutDeletedItemPartInput, DeletedItemPartUpdateManyMutationInput>
  }

  export type itemPartUpsertWithWhereUniqueWithoutSupplierInput = {
    where: itemPartWhereUniqueInput
    update: XOR<itemPartUncheckedUpdateWithoutSupplierInput, itemPartUpdateWithoutSupplierInput>
    create: XOR<itemPartUncheckedCreateWithoutSupplierInput, itemPartCreateWithoutSupplierInput>
  }

  export type itemPartUpdateWithWhereUniqueWithoutSupplierInput = {
    where: itemPartWhereUniqueInput
    data: XOR<itemPartUncheckedUpdateWithoutSupplierInput, itemPartUpdateWithoutSupplierInput>
  }

  export type itemPartUpdateManyWithWhereWithoutSupplierInput = {
    where: itemPartScalarWhereInput
    data: XOR<itemPartUncheckedUpdateManyWithoutItemPartInput, itemPartUpdateManyMutationInput>
  }

  export type departmentCreateWithoutVehicleInput = {
    departmentName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type departmentUncheckedCreateWithoutVehicleInput = {
    departmentId?: number
    departmentName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type departmentCreateOrConnectWithoutvehicleInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentUncheckedCreateWithoutVehicleInput, departmentCreateWithoutVehicleInput>
  }

  export type DeletedServiceExpenseCreateWithoutVehicleInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garage?: garageCreateNestedOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedCreateWithoutVehicleInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garageId?: number | null
  }

  export type DeletedServiceExpenseCreateOrConnectWithoutvehicleInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    create: XOR<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput, DeletedServiceExpenseCreateWithoutVehicleInput>
  }

  export type drivingCreateWithoutVehicleInput = {
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    reason?: string | null
    drivers?: driversCreateNestedOneWithoutDrivingInput
  }

  export type drivingUncheckedCreateWithoutVehicleInput = {
    drivingId?: number
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    driverId?: number | null
    reason?: string | null
  }

  export type drivingCreateOrConnectWithoutvehicleInput = {
    where: drivingWhereUniqueInput
    create: XOR<drivingUncheckedCreateWithoutVehicleInput, drivingCreateWithoutVehicleInput>
  }

  export type serviceExpenseCreateWithoutVehicleInput = {
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garage?: garageCreateNestedOneWithoutServiceExpenseInput
    itemPart?: itemPartCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedCreateWithoutVehicleInput = {
    id?: number
    invoiceNumber: string
    serviceDescription?: string | null
    serviceDate?: Date | string | null
    serviceCost?: number | null
    totalCost?: number | null
    purchaseID?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    garageId?: number | null
    itemPart?: itemPartUncheckedCreateNestedManyWithoutServiceExpenseInput
  }

  export type serviceExpenseCreateOrConnectWithoutvehicleInput = {
    where: serviceExpenseWhereUniqueInput
    create: XOR<serviceExpenseUncheckedCreateWithoutVehicleInput, serviceExpenseCreateWithoutVehicleInput>
  }

  export type departmentUpsertWithoutVehicleInput = {
    update: XOR<departmentUncheckedUpdateWithoutVehicleInput, departmentUpdateWithoutVehicleInput>
    create: XOR<departmentUncheckedCreateWithoutVehicleInput, departmentCreateWithoutVehicleInput>
  }

  export type departmentUpdateWithoutVehicleInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departmentUncheckedUpdateWithoutVehicleInput = {
    departmentId?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedServiceExpenseUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    update: XOR<DeletedServiceExpenseUncheckedUpdateWithoutVehicleInput, DeletedServiceExpenseUpdateWithoutVehicleInput>
    create: XOR<DeletedServiceExpenseUncheckedCreateWithoutVehicleInput, DeletedServiceExpenseCreateWithoutVehicleInput>
  }

  export type DeletedServiceExpenseUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DeletedServiceExpenseWhereUniqueInput
    data: XOR<DeletedServiceExpenseUncheckedUpdateWithoutVehicleInput, DeletedServiceExpenseUpdateWithoutVehicleInput>
  }

  export type DeletedServiceExpenseUpdateManyWithWhereWithoutVehicleInput = {
    where: DeletedServiceExpenseScalarWhereInput
    data: XOR<DeletedServiceExpenseUncheckedUpdateManyWithoutDeletedServiceExpenseInput, DeletedServiceExpenseUpdateManyMutationInput>
  }

  export type drivingUpsertWithWhereUniqueWithoutVehicleInput = {
    where: drivingWhereUniqueInput
    update: XOR<drivingUncheckedUpdateWithoutVehicleInput, drivingUpdateWithoutVehicleInput>
    create: XOR<drivingUncheckedCreateWithoutVehicleInput, drivingCreateWithoutVehicleInput>
  }

  export type drivingUpdateWithWhereUniqueWithoutVehicleInput = {
    where: drivingWhereUniqueInput
    data: XOR<drivingUncheckedUpdateWithoutVehicleInput, drivingUpdateWithoutVehicleInput>
  }

  export type drivingUpdateManyWithWhereWithoutVehicleInput = {
    where: drivingScalarWhereInput
    data: XOR<drivingUncheckedUpdateManyWithoutDrivingInput, drivingUpdateManyMutationInput>
  }

  export type drivingScalarWhereInput = {
    AND?: Enumerable<drivingScalarWhereInput>
    OR?: Enumerable<drivingScalarWhereInput>
    NOT?: Enumerable<drivingScalarWhereInput>
    drivingId?: IntFilter | number
    drivingDate?: DateTimeFilter | Date | string
    drivingDescription?: StringNullableFilter | string | null
    drivingStatus?: StringNullableFilter | string | null
    vehicleId?: IntNullableFilter | number | null
    driverId?: IntNullableFilter | number | null
    reason?: StringNullableFilter | string | null
  }

  export type serviceExpenseUpsertWithWhereUniqueWithoutVehicleInput = {
    where: serviceExpenseWhereUniqueInput
    update: XOR<serviceExpenseUncheckedUpdateWithoutVehicleInput, serviceExpenseUpdateWithoutVehicleInput>
    create: XOR<serviceExpenseUncheckedCreateWithoutVehicleInput, serviceExpenseCreateWithoutVehicleInput>
  }

  export type serviceExpenseUpdateWithWhereUniqueWithoutVehicleInput = {
    where: serviceExpenseWhereUniqueInput
    data: XOR<serviceExpenseUncheckedUpdateWithoutVehicleInput, serviceExpenseUpdateWithoutVehicleInput>
  }

  export type serviceExpenseUpdateManyWithWhereWithoutVehicleInput = {
    where: serviceExpenseScalarWhereInput
    data: XOR<serviceExpenseUncheckedUpdateManyWithoutServiceExpenseInput, serviceExpenseUpdateManyMutationInput>
  }

  export type drivingCreateWithoutDriversInput = {
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    reason?: string | null
    vehicle?: vehicleCreateNestedOneWithoutDrivingInput
  }

  export type drivingUncheckedCreateWithoutDriversInput = {
    drivingId?: number
    drivingDate: Date | string
    drivingDescription?: string | null
    drivingStatus?: string | null
    vehicleId?: number | null
    reason?: string | null
  }

  export type drivingCreateOrConnectWithoutdriversInput = {
    where: drivingWhereUniqueInput
    create: XOR<drivingUncheckedCreateWithoutDriversInput, drivingCreateWithoutDriversInput>
  }

  export type drivingUpsertWithWhereUniqueWithoutDriversInput = {
    where: drivingWhereUniqueInput
    update: XOR<drivingUncheckedUpdateWithoutDriversInput, drivingUpdateWithoutDriversInput>
    create: XOR<drivingUncheckedCreateWithoutDriversInput, drivingCreateWithoutDriversInput>
  }

  export type drivingUpdateWithWhereUniqueWithoutDriversInput = {
    where: drivingWhereUniqueInput
    data: XOR<drivingUncheckedUpdateWithoutDriversInput, drivingUpdateWithoutDriversInput>
  }

  export type drivingUpdateManyWithWhereWithoutDriversInput = {
    where: drivingScalarWhereInput
    data: XOR<drivingUncheckedUpdateManyWithoutDrivingInput, drivingUpdateManyMutationInput>
  }

  export type garageCreateWithoutDeletedItemPartInput = {
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutGarageInput
  }

  export type garageUncheckedCreateWithoutDeletedItemPartInput = {
    garageId?: number
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutGarageInput
  }

  export type garageCreateOrConnectWithoutDeletedItemPartInput = {
    where: garageWhereUniqueInput
    create: XOR<garageUncheckedCreateWithoutDeletedItemPartInput, garageCreateWithoutDeletedItemPartInput>
  }

  export type supplierCreateWithoutDeletedItemPartInput = {
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    itemPart?: itemPartCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateWithoutDeletedItemPartInput = {
    supplierId?: number
    supplierName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    itemPart?: itemPartUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierCreateOrConnectWithoutDeletedItemPartInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierUncheckedCreateWithoutDeletedItemPartInput, supplierCreateWithoutDeletedItemPartInput>
  }

  export type garageUpsertWithoutDeletedItemPartInput = {
    update: XOR<garageUncheckedUpdateWithoutDeletedItemPartInput, garageUpdateWithoutDeletedItemPartInput>
    create: XOR<garageUncheckedCreateWithoutDeletedItemPartInput, garageCreateWithoutDeletedItemPartInput>
  }

  export type garageUpdateWithoutDeletedItemPartInput = {
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUpdateManyWithoutGarageInput
  }

  export type garageUncheckedUpdateWithoutDeletedItemPartInput = {
    garageId?: IntFieldUpdateOperationsInput | number
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutGarageInput
  }

  export type supplierUpsertWithoutDeletedItemPartInput = {
    update: XOR<supplierUncheckedUpdateWithoutDeletedItemPartInput, supplierUpdateWithoutDeletedItemPartInput>
    create: XOR<supplierUncheckedCreateWithoutDeletedItemPartInput, supplierCreateWithoutDeletedItemPartInput>
  }

  export type supplierUpdateWithoutDeletedItemPartInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemPart?: itemPartUpdateManyWithoutSupplierInput
  }

  export type supplierUncheckedUpdateWithoutDeletedItemPartInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemPart?: itemPartUncheckedUpdateManyWithoutSupplierInput
  }

  export type driversCreateWithoutDrivingInput = {
    driverName: string
    phone: string
    licensNo: number
    description?: string | null
    driverStatus?: string | null
  }

  export type driversUncheckedCreateWithoutDrivingInput = {
    driverId?: number
    driverName: string
    phone: string
    licensNo: number
    description?: string | null
    driverStatus?: string | null
  }

  export type driversCreateOrConnectWithoutdrivingInput = {
    where: driversWhereUniqueInput
    create: XOR<driversUncheckedCreateWithoutDrivingInput, driversCreateWithoutDrivingInput>
  }

  export type vehicleCreateWithoutDrivingInput = {
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    department?: departmentCreateNestedOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutDrivingInput = {
    vehicleId?: number
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    departmentId?: number | null
    location?: string | null
    reason?: string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutdrivingInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleUncheckedCreateWithoutDrivingInput, vehicleCreateWithoutDrivingInput>
  }

  export type driversUpsertWithoutDrivingInput = {
    update: XOR<driversUncheckedUpdateWithoutDrivingInput, driversUpdateWithoutDrivingInput>
    create: XOR<driversUncheckedCreateWithoutDrivingInput, driversCreateWithoutDrivingInput>
  }

  export type driversUpdateWithoutDrivingInput = {
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driversUncheckedUpdateWithoutDrivingInput = {
    driverId?: IntFieldUpdateOperationsInput | number
    driverName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licensNo?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    driverStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicleUpsertWithoutDrivingInput = {
    update: XOR<vehicleUncheckedUpdateWithoutDrivingInput, vehicleUpdateWithoutDrivingInput>
    create: XOR<vehicleUncheckedCreateWithoutDrivingInput, vehicleCreateWithoutDrivingInput>
  }

  export type vehicleUpdateWithoutDrivingInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutVehicleInput
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateWithoutDrivingInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutVehicleInput
  }

  export type garageCreateWithoutDeletedServiceExpenseInput = {
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutGarageInput
  }

  export type garageUncheckedCreateWithoutDeletedServiceExpenseInput = {
    garageId?: number
    garageName: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedCreateNestedManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutGarageInput
  }

  export type garageCreateOrConnectWithoutDeletedServiceExpenseInput = {
    where: garageWhereUniqueInput
    create: XOR<garageUncheckedCreateWithoutDeletedServiceExpenseInput, garageCreateWithoutDeletedServiceExpenseInput>
  }

  export type vehicleCreateWithoutDeletedServiceExpenseInput = {
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    location?: string | null
    reason?: string | null
    department?: departmentCreateNestedOneWithoutVehicleInput
    driving?: drivingCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutDeletedServiceExpenseInput = {
    vehicleId?: number
    plateNumber: string
    model: string
    modelYear: number
    chasisNubmer: number
    purchaseDate: Date | string
    purchaseMileAge: number
    disposalDate?: Date | string | null
    vehicleStatus?: string | null
    departmentId?: number | null
    location?: string | null
    reason?: string | null
    driving?: drivingUncheckedCreateNestedManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutDeletedServiceExpenseInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleUncheckedCreateWithoutDeletedServiceExpenseInput, vehicleCreateWithoutDeletedServiceExpenseInput>
  }

  export type garageUpsertWithoutDeletedServiceExpenseInput = {
    update: XOR<garageUncheckedUpdateWithoutDeletedServiceExpenseInput, garageUpdateWithoutDeletedServiceExpenseInput>
    create: XOR<garageUncheckedCreateWithoutDeletedServiceExpenseInput, garageCreateWithoutDeletedServiceExpenseInput>
  }

  export type garageUpdateWithoutDeletedServiceExpenseInput = {
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUpdateManyWithoutGarageInput
  }

  export type garageUncheckedUpdateWithoutDeletedServiceExpenseInput = {
    garageId?: IntFieldUpdateOperationsInput | number
    garageName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeletedItemPart?: DeletedItemPartUncheckedUpdateManyWithoutGarageInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutGarageInput
  }

  export type vehicleUpsertWithoutDeletedServiceExpenseInput = {
    update: XOR<vehicleUncheckedUpdateWithoutDeletedServiceExpenseInput, vehicleUpdateWithoutDeletedServiceExpenseInput>
    create: XOR<vehicleUncheckedCreateWithoutDeletedServiceExpenseInput, vehicleCreateWithoutDeletedServiceExpenseInput>
  }

  export type vehicleUpdateWithoutDeletedServiceExpenseInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutVehicleInput
    driving?: drivingUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateWithoutDeletedServiceExpenseInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    driving?: drivingUncheckedUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutVehicleInput
  }

  export type vehicleUpdateWithoutDepartmentInput = {
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUpdateManyWithoutVehicleInput
    driving?: drivingUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateWithoutDepartmentInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    DeletedServiceExpense?: DeletedServiceExpenseUncheckedUpdateManyWithoutVehicleInput
    driving?: drivingUncheckedUpdateManyWithoutVehicleInput
    serviceExpense?: serviceExpenseUncheckedUpdateManyWithoutVehicleInput
  }

  export type vehicleUncheckedUpdateManyWithoutVehicleInput = {
    vehicleId?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelYear?: IntFieldUpdateOperationsInput | number
    chasisNubmer?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseMileAge?: IntFieldUpdateOperationsInput | number
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleStatus?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedItemPartUpdateWithoutGarageInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    supplier?: supplierUpdateOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedUpdateWithoutGarageInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedItemPartUncheckedUpdateManyWithoutDeletedItemPartInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedServiceExpenseUpdateWithoutGarageInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: vehicleUpdateOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedUpdateWithoutGarageInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedServiceExpenseUncheckedUpdateManyWithoutDeletedServiceExpenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceExpenseUpdateWithoutGarageInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: vehicleUpdateOneWithoutServiceExpenseInput
    itemPart?: itemPartUpdateManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedUpdateWithoutGarageInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    itemPart?: itemPartUncheckedUpdateManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedUpdateManyWithoutServiceExpenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemPartUpdateWithoutServiceExpenseInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: supplierUpdateOneWithoutItemPartInput
  }

  export type itemPartUncheckedUpdateWithoutServiceExpenseInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemPartUncheckedUpdateManyWithoutItemPartInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedItemPartUpdateWithoutSupplierInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    garage?: garageUpdateOneWithoutDeletedItemPartInput
  }

  export type DeletedItemPartUncheckedUpdateWithoutSupplierInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemPartUpdateWithoutSupplierInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceExpense?: serviceExpenseUpdateOneWithoutItemPartInput
  }

  export type itemPartUncheckedUpdateWithoutSupplierInput = {
    itemPart?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    partQuantity?: IntFieldUpdateOperationsInput | number
    partPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletedServiceExpenseUpdateWithoutVehicleInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garage?: garageUpdateOneWithoutDeletedServiceExpenseInput
  }

  export type DeletedServiceExpenseUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drivingUpdateWithoutVehicleInput = {
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    drivers?: driversUpdateOneWithoutDrivingInput
  }

  export type drivingUncheckedUpdateWithoutVehicleInput = {
    drivingId?: IntFieldUpdateOperationsInput | number
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type drivingUncheckedUpdateManyWithoutDrivingInput = {
    drivingId?: IntFieldUpdateOperationsInput | number
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceExpenseUpdateWithoutVehicleInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garage?: garageUpdateOneWithoutServiceExpenseInput
    itemPart?: itemPartUpdateManyWithoutServiceExpenseInput
  }

  export type serviceExpenseUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    serviceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    serviceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCost?: NullableIntFieldUpdateOperationsInput | number | null
    totalCost?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseID?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garageId?: NullableIntFieldUpdateOperationsInput | number | null
    itemPart?: itemPartUncheckedUpdateManyWithoutServiceExpenseInput
  }

  export type drivingUpdateWithoutDriversInput = {
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: vehicleUpdateOneWithoutDrivingInput
  }

  export type drivingUncheckedUpdateWithoutDriversInput = {
    drivingId?: IntFieldUpdateOperationsInput | number
    drivingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drivingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    drivingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}